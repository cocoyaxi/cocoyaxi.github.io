[{"id":0,"href":"/en/co/def/","title":"Basic definitions","section":"Documents for CO","content":"include: co/def.h.\n#typedefs\r#Fixed-length integer type\rdef.h defines the following 8 types of integers:\ntypedef int8_t int8; typedef int16_t int16; typedef int32_t int32; typedef int64_t int64; typedef uint8_t uint8; typedef uint16_t uint16; typedef uint32_t uint32; typedef uint64_t uint64; These types have the same length on different platforms, and there is no portability problem. Google Code Style recommends not to use built-in integer types such as short, long, long long, etc.\n#macros\r#Maximum and minimum values of integer types\rMAX_UINT8 MAX_UINT16 MAX_UINT32 MAX_UINT64 MAX_INT8 MAX_INT16 MAX_INT32 MAX_INT64 MIN_INT8 MIN_INT16 MIN_INT32 MIN_INT64 These macros respectively defines the maximum and minimum values of the 8 integer types.\n#DISALLOW_COPY_AND_ASSIGN\rThis macro is used to disable copy constructor and assignment operations in C++ classes.\n Example  class T {  public:  T();  DISALLOW_COPY_AND_ASSIGN(T); }; #__forceinline\r__forceinline is a keyword in VS. Linux and mac platforms use the following macro simulation:\n#define __forceinline __attribute__((always_inline)) #__thread\r__thread is a keyword in gcc/clang to support TLS, the windows platform uses the following macro simulation:\n#define __thread __declspec(thread)  Example  // get id of the current thread __forceinline unsigned int gettid() {  static __thread unsigned int id = 0;  if (id != 0) return id;  return id = __gettid(); } #unlikely\rThis macro is used for branch prediction optimization. It only supports gcc/clang.\n Example  // It is logically equivalent to if (v == 0) if (unlikey(v == 0)) {  cout \u0026lt;\u0026lt; \u0026#34;v == 0\u0026#34; \u0026lt;\u0026lt; endl; } "},{"id":1,"href":"/en/co/defer/","title":"defer","section":"Documents for CO","content":"include: co/defer.h.\n#defer\rdefer is a macro provided by CO, which is similar to defer in golang.\n#include \u0026#34;co/defer.h\u0026#34;#include \u0026#34;co/time.h\u0026#34;#include \u0026#34;co/log.h\u0026#34;#include \u0026#34;co/json.h\u0026#34; void f(const Json\u0026amp; req, Json\u0026amp; res) {  Timer t;  LOG \u0026lt;\u0026lt; \u0026#34;req: \u0026#34; \u0026lt;\u0026lt; req;  defer(LOG \u0026lt;\u0026lt; \u0026#34;res: \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;, time elapse: \u0026#34; \u0026lt;\u0026lt; t.us() \u0026lt;\u0026lt; \u0026#34;us\u0026#34;);   // do something here } In the above example, the code in defer will be executed at the end of the function f, thus printing the output and time elapse of the function.\n"},{"id":2,"href":"/en/about/co/","title":"Introduction","section":"About","content":"#What is CO\rCO is an elegant and efficient C++ base library that supports Linux, Windows and Mac platforms. It implements a series of high-quality base components, such as go-style coroutine, coroutine-based network programming framework, command line parameter and config file parsing library, high-performance log library, unit testing framework, JSON library, etc.\nCO is an open source project on github under the MIT license. It contains code from some other projects, which may have different licenses, see LICENSE file for details.\n#History of CO\rAlvin(idealvin) has started to develop CO since 2013. The original purpose is to reduce third-party dependencies in C++ projects and improve the efficiency of C++ development. Beginning in 2015, Alvin introduced CO into industrial projects for use by himself and his colleagues, which greatly reduced the development cycle of C++ projects.\nAfter years of accumulation and precipitation, by 2019, Alvin implemented the coroutine mechanism in golang with C++ and provided a set of network programming framework based on coroutine. At the beginning of its birth, it was used in the development of embedded network programming and achieved immediate results.\nAs of 2021, CO coroutines have made considerable progress. At present, hooks are supported on Linux/Windows/Mac platforms, and coroutine lock, coroutine synchronization event, coroutine pool, and channel and waitgroup in golang have been implemented. Users can use CO to write C++ like golang.\n#Quick Start\r#Compiling\rIt is recommended to install xmake and run the following command in the root directory of CO to build all sub-projects:\nxmake -a If you need to use http::Client, SSL or HTTPS features, you can use the following command to build:\nxmake f --with_libcurl=true --with_openssl=true xmake -a Xmake will automatically install libcurl and openssl from the network. Depending on the network, this process may be slow. xmake -a will build libco, gen, co/unitest and co/test. Users can run test programs in CO with the following commands:\nxmake r unitest -a xmake r flag xmake r log -cout xmake r co #Develop C++ projects with CO\rThe simplest, you can directly include co/all.h and use all the features in CO. If you are worried about the compiling speed, you can also include only the header files that you need, such as including co/co.h, you can use co/flag, co/log and all features related to coroutines.\n#include \u0026#34;co/all.h\u0026#34; DEF_string(s, \u0026#34;nice\u0026#34;, \u0026#34;\u0026#34;);  int main(int argc, char** argv) {  flag::init(argc, argv);  log::init();   LOG \u0026lt;\u0026lt; FLG_s;  return 0; } The above is a simple example. The first two lines of the main function are used to initialize the flag and log libraries. Some components in CO use co/flag to define config items and use co/log to print logs. Therefore, it is generally necessary to call flag::init() and log::init() at the beginning of the main function for initialization.\nUsers can also use the macro DEF_main to define the main function:\n#include \u0026#34;co/all.h\u0026#34; DEF_string(s, \u0026#34;nice\u0026#34;, \u0026#34;\u0026#34;);  DEF_main(argc, argv) {  LOG \u0026lt;\u0026lt; FLG_s;  return 0; } DEF_main has already called flag::init() and log::init() internally, and users do not need to call them again. In addition, DEF_main makes code in the main function also run in coroutine, which is consistent with golang. Some coroutine-related components in CO must be used in coroutine. When CO is used to develop coroutine-based applications, it is recommended to define the main function with DEF_main.\n#Core features\r#co/flag\rco/flag is a simple and easy-to-use command line and config file parsing library. Some components in CO use it to define config items.\nco/flag provides a default value for each config item. Without config parameters, the program can run with the default config. Users can also pass in config parameters from command line or config file. When a config file is needed, users can run ./exe -mkconf to generate a config file.\n// xx.cc #include \u0026#34;co/flag.h\u0026#34;#include \u0026#34;co/log.h\u0026#34; DEF_bool(x, false, \u0026#34;bool x\u0026#34;); DEF_bool(y, false, \u0026#34;bool y\u0026#34;); DEF_uint32(u32, 0, \u0026#34;...\u0026#34;); DEF_string(s, \u0026#34;hello world\u0026#34;, \u0026#34;string\u0026#34;);  int main(int argc, char** argv) {  flag::init(argc, argv);   COUT \u0026lt;\u0026lt; \u0026#34;x: \u0026#34;\u0026lt;\u0026lt; FLG_x;  COUT \u0026lt;\u0026lt; \u0026#34;y: \u0026#34;\u0026lt;\u0026lt; FLG_y;  COUT \u0026lt;\u0026lt; \u0026#34;u32: \u0026#34;\u0026lt;\u0026lt; FLG_u32;  COUT \u0026lt;\u0026lt; FLG_s \u0026lt;\u0026lt; \u0026#34;|\u0026#34; \u0026lt;\u0026lt; FLG_s.size();   return 0; } The above is an example of using co/flag. The macro at the beginning of DEF_ in the code defines 4 config items. Each config item is equivalent to a global variable. The variable name is FLG_ plus the config name. After the above code is compiled, it can be run as follows:\n./xx # Run with default configs ./xx -xy -s good # single letter named bool flags, can be set to true together ./xx -s \u0026#34;I\u0026#39;m ok\u0026#34; # string with spaces ./xx -u32 8k # Integers can have units: k,m,g,t,p, not case sensitive  ./xx -mkconf # Automatically generate a config file: xx.conf ./xx xx.conf # run with a config file ./xx -config xx.conf # Same as above #co/log\rco/log is a high-performance local log library, some components in CO use it to print logs.\nco/log divides the log into five levels: debug, info, warning, error, and fatal. Printing a fatal level log will terminate the program. Users can print logs of different levels as follows:\nDLOG \u0026lt;\u0026lt; \u0026#34;hello \u0026#34;\u0026lt;\u0026lt; 23; // debug LOG \u0026lt;\u0026lt; \u0026#34;hello \u0026#34;\u0026lt;\u0026lt; 23; // info WLOG \u0026lt;\u0026lt; \u0026#34;hello \u0026#34;\u0026lt;\u0026lt; 23; // warning ELOG \u0026lt;\u0026lt; \u0026#34;hello \u0026#34;\u0026lt;\u0026lt; 23; // error FLOG \u0026lt;\u0026lt; \u0026#34;hello \u0026#34;\u0026lt;\u0026lt; 23; // fatal co/log also provides a series of CHECK macros, which can be regarded as an enhanced version of assert, and they will not be cleared in debug mode.\nvoid* p = malloc(32); CHECK(p != NULL) \u0026lt;\u0026lt; \u0026#34;malloc failed..\u0026#34;; CHECK_NE(p, NULL) \u0026lt;\u0026lt; \u0026#34;malloc failed..\u0026#34;; When the CHECK assertion fails, co/log will print the function call stack information, and then terminate the program.\nco/log is very fast. The following are some test results, for reference only:\n  co/log vs glog (single thread)\n   platform google glog co/log     win2012 HHD 1.6MB/s 180MB/s   win10 SSD 3.7MB/s 560MB/s   mac SSD 17MB/s 450MB/s   linux SSD 54MB/s 1023MB/s      co/log vs spdlog (Windows)\n   threads total logs co/log time(seconds) spdlog time(seconds)     1 1000000 0.103619 0.482525   2 1000000 0.202246 0.565262   4 1000000 0.330694 0.722709   8 1000000 0.386760 1.322471      co/log vs spdlog (Linux)\n   threads total logs co/log time(seconds) spdlog time(seconds)     1 1000000 0.096445 2.006087   2 1000000 0.142160 3.276006   4 1000000 0.181407 4.339714   8 1000000 0.303968 4.700860      #co/unitest\rco/unitest is a simple and easy-to-use unit test framework. Many components in CO use it to write unit test code, which guarantees the stability of CO.\n#include \u0026#34;co/unitest.h\u0026#34;#include \u0026#34;co/os.h\u0026#34; namespace test {  DEF_test(os) {  DEF_case(homedir) {  EXPECT_NE(os::homedir(), \u0026#34;\u0026#34;);  }   DEF_case(cpunum) {  EXPECT_GT(os::cpunum(), 0);  } }  } // namespace test The above is a simple example. The DEF_test macro defines a test unit, which is actually a function (a method in a class). The DEF_case macro defines test cases, and each test case is actually a code block. Multiple test units can be put in the same C++ project, the main function is simple as below:\n#include \u0026#34;co/unitest.h\u0026#34; int main(int argc, char** argv) {  flag::init(argc, argv);  unitest::run_all_tests();  return 0; } co/unitest contains the unit test code in CO. Users can run unitest with the following commands:\nxmake r unitest -a # Run all test cases xmake r unitest -os # Run test cases in the os unit #Coroutine\rCO has implemented a go-style coroutine, which has the following features:\n Multi-thread scheduling, the default number of threads is the number of system CPU cores. Shared stack, coroutines in the same thread share several stacks (the default size is 1MB), and the memory usage is low. Simple test on Linux shows that 10 millions of coroutines only take 2.8G of memory (for reference only). There is a flat relationship between coroutines, and new coroutines can be created from anywhere (including in coroutines). Support system API hook (Windows/Linux/Mac), you can directly use third-party network library in coroutine. Coroutineized socket API. Coroutine synchronization event co::Event. Coroutine lock co::Mutex. Coroutine pool co::Pool. channel co::Chan. waitgroup co::WaitGroup.  #Create a coroutine\rgo(ku); // void ku(); go(f, 7); // void f(int); go(\u0026amp;T::f, \u0026amp;o); // void T::f(); T o; go(\u0026amp;T::f, \u0026amp;o, 7); // void T::f(int); T o; go([](){  LOG \u0026lt;\u0026lt; \u0026#34;hello go\u0026#34;; }); The above is an example of creating coroutines with go(). go() is a function that accepts 1 to 3 parameters. The first parameter f is any callable object, as long as f(), (*f)(), f(p), (*f)(p), (o-\u0026gt;*f)() or (o-\u0026gt;*f)(p) can be called.\nThe coroutines created by go() will be evenly distributed to different scheduling threads. If users want some coroutines to run in the same thread, they can create coroutines in the following way:\nauto s = co::next_scheduler(); s-\u0026gt;go(f1); s-\u0026gt;go(f2); If users want to create coroutine in all scheduling threads, the following way can be used:\nauto\u0026amp; s = co::all_schedulers(); for (size_t i = 0; i \u0026lt;s.size(); ++i) {  s[i]-\u0026gt;go(f); } #channel\rco::Chan, similar to the channel in golang, can be used to transfer data between coroutines.\n#include \u0026#34;co/co.h\u0026#34; DEF_main(argc, argv) {  co::Chan\u0026lt;int\u0026gt; ch;  go([ch]() {  ch \u0026lt;\u0026lt; 7;  });   int v = 0;  ch \u0026gt;\u0026gt; v;  LOG \u0026lt;\u0026lt; \u0026#34;v: \u0026#34;\u0026lt;\u0026lt; v;   return 0; } The read and write operations of channel must be performed in coroutine, so the main function is defined with DEF_main in above code, so that code in the main function also runs in coroutine.\nThe channel object in the code is on the stack, while CO uses a shared stack implementation. Data on the stack of one coroutine may be overwritten by other coroutines. Generally, we cann\u0026rsquo;t share data on stack between coroutines. Therefore, we capture by value in the lambda to copy the channel and pass it to the newly created coroutine. The copy operation just increases the internal reference count by 1 and will not affect the performance.\nWhen creating a channel, we can add a timeout as follows:\nco::Chan\u0026lt;int\u0026gt; ch(8, 1000); After read or write operation, we can call co::timeout() to determine whether it has timed out. This method is simpler than the select-based implementation in golang.\nThe channel in CO is implemented based on memory copy. The data type passed can be a built-in type, a pointer type, or a structure type with simple memory copy semantics for the copy operation. Like std::string or container types in STL, the copy operation is not a simple memory copy, and generally cannot be passed directly in channel. For details, see Document of co::Chan.\n#waitgroup\rco::WaitGroup, similar to sync.WaitGroup in golang, can be used to wait for the exit of coroutines or threads.\n#include \u0026#34;co/co.h\u0026#34; DEF_main(argc, argv) {  FLG_cout = true;   co::WaitGroup wg;  wg.add(8);   for (int i = 0; i \u0026lt;8; ++i) {  go([wg]() {  LOG \u0026lt;\u0026lt; \u0026#34;co: \u0026#34;\u0026lt;\u0026lt; co::coroutine_id();  wg.done();  });  }   wg.wait();  return 0; } #network programming\rCO provides a set of coroutineized socket APIs, most of them are consistent with the native socket APIs in form. In addition, CO has also implemented higher-level network programming components, including TCP, HTTP and RPC framework based on JSON, they are IPv6-compatible and support SSL at the same time, which is more convenient than socket APIs. Here is just a brief demonstration of the usage of HTTP, and the rest can be viewed in the documents.\nStatic web server\n#include \u0026#34;co/flag.h\u0026#34;#include \u0026#34;co/log.h\u0026#34;#include \u0026#34;co/so.h\u0026#34; DEF_string(d, \u0026#34;.\u0026#34;, \u0026#34;root dir\u0026#34;); // Specify the root directory of the web server  int main(int argc, char** argv) {  flag::init(argc, argv);  log::init();   so::easy(FLG_d.c_str()); // mum never have to worry again   return 0; } HTTP server\nhttp::Server serv;  serv.on_req(  [](const http::Req\u0026amp; req, http::Res\u0026amp; res) {  if (req.is_method_get()) {  if (req.url() == \u0026#34;/hello\u0026#34;) {  res.set_status(200);  res.set_body(\u0026#34;hello world\u0026#34;);  } else {  res.set_status(404);  }  } else {  res.set_status(405); // method not allowed  }  } );  serv.start(\u0026#34;0.0.0.0\u0026#34;, 80); // http serv.start(\u0026#34;0.0.0.0\u0026#34;, 443, \u0026#34;privkey.pem\u0026#34;, \u0026#34;certificate.pem\u0026#34;); // https HTTP client\nvoid f() {  http::Client c(\u0026#34;https://github.com\u0026#34;);   c.get(\u0026#34;/\u0026#34;);  LOG \u0026lt;\u0026lt; \u0026#34;response code: \u0026#34;\u0026lt;\u0026lt; c.response_code();  LOG \u0026lt;\u0026lt; \u0026#34;body size: \u0026#34;\u0026lt;\u0026lt; c.body_size();  LOG \u0026lt;\u0026lt; \u0026#34;Content-Length: \u0026#34;\u0026lt;\u0026lt; c.header(\u0026#34;Content-Length\u0026#34;);  LOG \u0026lt;\u0026lt; c.header();   c.post(\u0026#34;/hello\u0026#34;, \u0026#34;data xxx\u0026#34;);  LOG \u0026lt;\u0026lt; \u0026#34;response code: \u0026#34;\u0026lt;\u0026lt; c.response_code(); }  go(f); "},{"id":3,"href":"/en/co/atomic/","title":"Atomic Operations","section":"Documents for CO","content":"include: co/atomic.h.\n#Arithmetic operations\r#atomic_inc\rtemplate\u0026lt;typename T\u0026gt; inline T atomic_inc(T* p);   Atomic increment, T is any integer type with a length of 1, 2, 4, 8 bytes, and the parameter p is a pointer of type T.\n  This function performs an increment operation on the integer pointed to by p and returns the result after increment.\n  Example\n  int i = 0; uint64 u = 0; int r = atomic_inc(\u0026amp;i); // i -\u0026gt; 1, r = 1 uint64 x = atomic_inc(\u0026amp;u); // u -\u0026gt; 1, x = 1 #atomic_fetch_inc\rtemplate\u0026lt;typename T\u0026gt; inline T atomic_fetch_inc(T* p);   The same as atomic_inc, but returns the value before increment.\n  Example\n  int i = 0; uint64 u = 0; int r = atomic_fetch_inc(\u0026amp;i); // i -\u0026gt; 1, r = 0 uint64 x = atomic_fetch_inc(\u0026amp;u); // u -\u0026gt; 1, x = 0 #atomic_dec\rtemplate\u0026lt;typename T\u0026gt; inline T atomic_dec(T* p);   Atomic decrement, T is any integer type with a length of 1, 2, 4, 8 bytes, and the parameter p is a pointer of type T.\n  This function decrements the integer pointed to by p and returns the decremented result.\n  Example\n  int i = 1; uint64 u = 1; int r = atomic_dec(\u0026amp;i); // i -\u0026gt; 0, r = 0 uint64 x = atomic_dec(\u0026amp;u); // u -\u0026gt; 0, x = 0 #atomic_fetch_dec\rtemplate\u0026lt;typename T\u0026gt; inline T atomic_fetch_dec(T* p);   The same as atomic_dec, but returns the value before decrement.\n  Example\n  int i = 1; uint64 u = 1; int r = atomic_fetch_dec(\u0026amp;i); // i -\u0026gt; 0, r = 1 uint64 x = atomic_fetch_dec(\u0026amp;u); // u -\u0026gt; 0, x = 1 #atomic_add\rtemplate\u0026lt;typename T, typename V\u0026gt; inline T atomic_add(T* p, V v);   Atomic addition, T is any integer type with a length of 1, 2, 4, 8 bytes, V is any integer type, and the parameter p is a pointer of type T.\n  This function adds the value v to the integer pointed to by p, and returns the result after adding v.\n  Example\n  int i = 0; uint64 u = 0; int r = atomic_add(\u0026amp;i, 1); // i -\u0026gt; 1, r = 1 uint64 x = atomic_add(\u0026amp;u, 1); // u -\u0026gt; 1, x = 1 #atomic_fetch_add\rtemplate\u0026lt;typename T, typename V\u0026gt; inline T atomic_fetch_add(T* p, V v);   The same as atomic_add, but returns the value before adding v.\n  Example\n  int i = 0; uint64 u = 0; int r = atomic_fetch_add(\u0026amp;i, 1); // i -\u0026gt; 1, r = 0 uint64 x = atomic_fetch_add(\u0026amp;u, 1); // u -\u0026gt; 1, x = 0 #atomic_sub\rtemplate\u0026lt;typename T, typename V\u0026gt; inline T atomic_sub(T* p, V v);   Atomic subtraction, T is any integer type with a length of 1, 2, 4, 8 bytes, V is any integer type, and the parameter p is a pointer of type T.\n  This function subtracts value v from the integer pointed to by p, and returns the result of subtracting v.\n  Example\n  int i = 1; uint64 u = 1; int r = atomic_sub(\u0026amp;i, 1); // i -\u0026gt; 0, r = 0 uint64 x = atomic_sub(\u0026amp;u, 1); // u -\u0026gt; 0, x = 0 #atomic_fetch_sub\rtemplate\u0026lt;typename T, typename V\u0026gt; inline T atomic_fetch_sub(T* p, V v);   The same as atomic_sub, but returns the value before subtracting v.\n  Example\n  int i = 1; uint64 u = 1; int r = atomic_fetch_sub(\u0026amp;i, 1); // i -\u0026gt; 0, r = 1 uint64 x = atomic_fetch_sub(\u0026amp;u, 1); // u -\u0026gt; 0, x = 1 #Bit operation\r#atomic_or\rtemplate\u0026lt;typename T, typename V\u0026gt; inline T atomic_or(T* p, V v);   Atomic bitwise OR operation, T is any integer type with a length of 1, 2, 4, 8 bytes, V is any integer type, and the parameter p is a pointer of type T.\n  This function performs bitwise OR operation on the integer pointed to by p and v, and returns the result of the operation.\n  Example\n  int i = 5; uint64 u = 5; int r = atomic_or(\u0026amp;i, 3); // i |= 3, i -\u0026gt; 7, r = 7 uint64 x = atomic_or(\u0026amp;u, 3); // u |= 3, u -\u0026gt; 7, x = 7 #atomic_fetch_or\rtemplate\u0026lt;typename T, typename V\u0026gt; inline T atomic_fetch_or(T* p, V v);   The same as atomic_or, but returns the value before the bitwise OR operation.\n  Example\n  int i = 5; uint64 u = 5; int r = atomic_fetch_or(\u0026amp;i, 3); // i |= 3, i -\u0026gt; 7, r = 5 uint64 x = atomic_fetch_or(\u0026amp;u, 3); // u |= 3, u -\u0026gt; 7, x = 5 #atomic_and\rtemplate\u0026lt;typename T, typename V\u0026gt; inline T atomic_and(T* p, V v);   Atomic bitwise AND operation, T is any integer type with a length of 1, 2, 4, 8 bytes, V is any integer type, and the parameter p is a pointer of type T.\n  This function performs bitwise AND operation on the integer pointed to by p and v, and returns the result after the operation.\n  Example\n  int i = 5; uint64 u = 5; int r = atomic_and(\u0026amp;i, 3); // i \u0026amp;= 3, i -\u0026gt; 1, r = 1 uint64 x = atomic_and(\u0026amp;u, 3); // u \u0026amp;= 3, u -\u0026gt; 1, x = 1 #atomic_fetch_and\rtemplate\u0026lt;typename T, typename V\u0026gt; inline T atomic_fetch_and(T* p, V v);   The same as atomic_and, but returns the value before the bitwise AND operation.\n  Example\n  int i = 5; uint64 u = 5; int r = atomic_fetch_and(\u0026amp;i, 3); // i \u0026amp;= 3, i -\u0026gt; 1, r = 5 uint64 x = atomic_fetch_and(\u0026amp;u, 3); // u \u0026amp;= 3, u -\u0026gt; 1, x = 5 #atomic_xor\rtemplate\u0026lt;typename T, typename V\u0026gt; inline T atomic_xor(T* p, V v);   Atomic bitwise XOR operation, T is any integer type with a length of 1, 2, 4, 8 bytes, V is any integer type, and the parameter p is a pointer of type T.\n  This function performs a bitwise XOR operation on the integer pointed to by p and v, and returns the result of the operation.\n  Example\n  int i = 5; uint64 u = 5; int r = atomic_xor(\u0026amp;i, 3); // i ^= 3, i -\u0026gt; 6, r = 6 uint64 x = atomic_xor(\u0026amp;u, 3); // u ^= 3, u -\u0026gt; 6, x = 6 #atomic_fetch_xor\rtemplate\u0026lt;typename T, typename V\u0026gt; inline T atomic_fetch_xor(T* p, V v);   The same as atomic_xor, but returns the value before the bitwise XOR operation.\n  Example\n  int i = 5; uint64 u = 5; int r = atomic_fetch_xor(\u0026amp;i, 3); // i ^= 3, i -\u0026gt; 6, r = 5 uint64 x = atomic_fetch_xor(\u0026amp;u, 3); // u ^= 3, u -\u0026gt; 6, x = 5 #Exchange\r#atomic_swap\rtemplate\u0026lt;typename T, typename V\u0026gt; inline T atomic_swap(T* p, V v);   Atomic swap operation, T is any built-in type (including pointer type) with a length of 1, 2, 4, 8 bytes, and V is any type that can be converted to type of T.\n  This function exchanges the value pointed to by p and v, and returns the value before the exchange.\n  Example\n  bool b = false; int i = 0; void* p = 0; bool x = atomic_swap(\u0026amp;b, true); // b -\u0026gt; true, x = false int r = atomic_swap(\u0026amp;i, 1); // i -\u0026gt; 1, r = 0 void* q = atomic_swap(\u0026amp;p, (void*)8); // p -\u0026gt; 8, q = 0 #atomic_compare_swap\rtemplate\u0026lt;typename T, typename O, typename V\u0026gt; inline T atomic_compare_swap(T* p, O o, V v);   Atomic swap operation, T is any built-in type (including pointer type) with a length of 1, 2, 4, 8 bytes, O and V are any types that can be converted to type of T.\n  This function exchanges with v only when the value pointed to by p is equal to o.\n  This function returns the value before the exchange operation. The user can judge whether the exchange operation is performed according to whether the return value is equal to o.\n  Example\n  bool b = false; int i = 0; void* p = 0; bool x = atomic_compare_swap(\u0026amp;b, false, true); // b -\u0026gt; true, x = false int r = atomic_compare_swap(\u0026amp;i, 1, 2); // No swap, i remains unchanged, r = 0 void* q = atomic_compare_swap(\u0026amp;p, 0, (void*)8); // p -\u0026gt; 8, q = 0 #get \u0026amp; set\r#atomic_get\rtemplate\u0026lt;typename T\u0026gt; inline T atomic_get(T* p);   This function gets the value of the variable pointed to by p, T is any built-in type (including pointer type) with a length of 1, 2, 4, 8 bytes.\n  Example\n  int i = 7; int r = atomic_get(\u0026amp;i); // r = 7 #atomic_set\rtemplate\u0026lt;typename T, typename V\u0026gt; inline void atomic_set(T* p, V v);   This function sets the value pointed to by p to v, T is any built-in type (including pointer type) with a length of 1, 2, 4, 8 bytes, and V is any type that can be converted to type of T.\n  Example\n  int i = 7; atomic_set(\u0026amp;i, 3); // i -\u0026gt; 3 #atomic_reset\rtemplate\u0026lt;typename T\u0026gt; inline void atomic_reset(T* p);   This function sets the value pointed to by p to 0, and T is any built-in type (including pointer types) with a length of 1, 2, 4, or 8 bytes.\n  Example\n  int i = 7; void* p = \u0026amp;i; atomic_reset(\u0026amp;i); // i -\u0026gt; 0 atomic_reset(\u0026amp;p); // p -\u0026gt; 0 "},{"id":4,"href":"/en/about/contact/","title":"Contact","section":"About","content":"Contact\n Email: idealvin@qq.com github: https://github.com/idealvin/co gitee: https://gitee.com/idealvin/co zhihu: idealvin  "},{"id":5,"href":"/en/co/fastring/","title":"fastring","section":"Documents for CO","content":"include: co/fastring.h.\n#fastring\rfastring is the string type in co. It implements most of the methods in std::string and also provides some methods that std::string does not support.\n#fastring::fastring\r1. fastring() noexcept; 2. explicit fastring(size_t cap); 3. fastring(const void* s, size_t n); 4. fastring(const char* s); 5. fastring(const std::string\u0026amp; s); 6. fastring(size_t n, char c); 7. fastring(char c, size_t n); 8. fastring(const fastring\u0026amp; s); 9. fastring(fastring\u0026amp;\u0026amp; s) noexcept;   The first is the default constructor, which creates an empty fastring without allocating any memory.\n  The second constructor also creates an empty fastring, but uses the parameter cap to specify the initial capacity.\n  The third constructor creates a fastring from the given byte sequence, and the parameter n is the sequence length.\n  The fourth constructor creates a fastring from a null-terminated string.\n  The fifth constructor creates a fastring from std::string.\n  The sixth and seventh constructors initialize fastring to a string of n characters c.\n  The eighth is the copy constructor, which will copy the internal memory.\n  The ninth one is the move constructor, which does not copy the memory.\n  Example\n  fastring s; // empty string, no memory allocation fastring s(32); // empty string, pre-allocated memory (capacity is 32) fastring s(\u0026#34;hello\u0026#34;); // initialize s to \u0026#34;hello\u0026#34; fastring s(\u0026#34;hello\u0026#34;, 3); // initialize s to \u0026#34;hel\u0026#34; fastring s(88,\u0026#39;x\u0026#39;); // initialize s to 88 \u0026#39;x\u0026#39; fastring s(\u0026#39;x\u0026#39;, 88); // initialize s to 88 \u0026#39;x\u0026#39; fastring t(s); // copy construction fastring x(std::move(s)); // Move construction, s itself becomes an empty string #fastring::operator=\rfastring\u0026amp; operator=(const char* s); fastring\u0026amp; operator=(const std::string\u0026amp; s); fastring\u0026amp; operator=(const fastring\u0026amp; s); fastring\u0026amp; operator=(fastring\u0026amp;\u0026amp; s) noexcept;   Assign value of a string to fastring.\n  Example\n  fastring s; fastring t; s = \u0026#34;hello\u0026#34;; // s -\u0026gt; \u0026#34;hello\u0026#34; s = s; // nothing will be done s = s.c_str() + 2; // s -\u0026gt; \u0026#34;llo\u0026#34; s = std::string(\u0026#34;x\u0026#34;); // s -\u0026gt; \u0026#34;x\u0026#34; t = s; // t -\u0026gt; \u0026#34;x\u0026#34; t = std::move(s); // t -\u0026gt; \u0026#34;x\u0026#34;, s -\u0026gt; \u0026#34;\u0026#34; #———————————\r#fastring::back\rchar\u0026amp; back() const;   This method returns a reference to the last character in fastring.\n  If fastring is empty, calling this method will cause undefined behavior.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); char c = s.back(); // c =\u0026#39;o\u0026#39; s.back() =\u0026#39;x\u0026#39;; // s -\u0026gt; \u0026#34;hellx\u0026#34; #fastring::front\rchar\u0026amp; front() const;  This method returns the reference of the first character in fastring. If fastring is empty, calling this method will cause undefined behavior. Example  fastring s(\u0026#34;hello\u0026#34;); char c = s.front(); // c =\u0026#39;h\u0026#39; s.front() =\u0026#39;x\u0026#39;; // s -\u0026gt; \u0026#34;xello\u0026#34; #fastring::operator[]\rchar\u0026amp; operator[](size_t n) const;   This method returns the reference of the nth character in fastring.\n  If n is out of a reasonable range, calling this method will cause undefined behavior.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); char c = s[1]; // c =\u0026#39;e\u0026#39; s[1] =\u0026#39;x\u0026#39;; // s -\u0026gt; \u0026#34;hxllo\u0026#34; #———————————\r#fastring::capacity\rsize_t capacity() const;  This method returns the capacity of fastring.  #fastring::c_str\rconst char* c_str() const;  This method gets the equivalent C string. This method adds a \u0026lsquo;\\0\u0026rsquo; to the end of fastring, it will not change the size and content of fastring, but it may cause internal reallocation of memory.  #fastring::data\rconst char* data() const;  This method is similar to c_str(), but it does not guarantee that the string ends with \u0026lsquo;\\0\u0026rsquo;.  #fastring::empty\rbool empty() const;  This method determines whether fastring is empty.  #fastring::size\rsize_t size() const;  This method returns the length of fastring.  #fastring::substr\rfastring substr(size_t pos) const; fastring substr(size_t pos, size_t len) const;   The first version returns the substring starting at position pos.\n  The second version returns a substring of length len starting at position pos.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); s.substr(2); // \u0026#34;llo\u0026#34; s.substr(2, 2); // \u0026#34;ll\u0026#34; #———————————\r#fastring::append\r1. fastring\u0026amp; append(const void* s, size_t n); 2. fastring\u0026amp; append(const char* s); 3. fastring\u0026amp; append(const fastring\u0026amp; s); 4. fastring\u0026amp; append(const std::string\u0026amp; s); 5. fastring\u0026amp; append(size_t n, char c); 6. fastring\u0026amp; append(char c, size_t n); 7. fastring\u0026amp; append(char c); 8. fastring\u0026amp; append(signed char c); 9. fastring\u0026amp; append(unsigned char c);   The first version appends a byte sequence, and n is the sequence length.\n  The second version appends a string ending with \u0026lsquo;\\0\u0026rsquo;, and s can be part of fastring that performs the append operation.\n  The third version appends a fastring, and s can be the fastring itself that performs the append operation.\n  The fourth version appends a std::string.\n  The 5th and 6th versions appends n characters c.\n  The 7th to 9th version appends a single character c.\n  This method returns a fastring reference, multiple append operations can be written to one line.\n  Example\n  fastring s; s.append(\u0026#39;c\u0026#39;); // s -\u0026gt; \u0026#34;c\u0026#34; s.append(2,\u0026#39;c\u0026#39;); // s -\u0026gt; \u0026#34;ccc\u0026#34; s.append(\u0026#39;c\u0026#39;, 2); // s -\u0026gt; \u0026#34;ccccc\u0026#34; s.clear(); s.append(\u0026#39;c\u0026#39;).append(2,\u0026#39;x\u0026#39;); // s -\u0026gt; \u0026#34;cxx\u0026#34; s.append(s.c_str() + 1); // s -\u0026gt; \u0026#34;cxxxx\u0026#34; s.append(s.data(), 3); // s -\u0026gt; \u0026#34;cxxxxcxx\u0026#34; #fastring::cat\rtemplate\u0026lt;typename X, typename ...V\u0026gt; fastring\u0026amp; cat(X\u0026amp;\u0026amp; x, V\u0026amp;\u0026amp; ... v);   Added in v2.0.3. Concatenate any number of elements to fastring.\n  This method appends elements in the parameters to fastring one by one through operator\u0026lt;\u0026lt;.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); s.cat(\u0026#39;\u0026#39;, 23, \u0026#34;xx\u0026#34;, false); // s -\u0026gt; \u0026#34;hello 23xxfalse\u0026#34; #fastring::operator\u0026laquo;\rfastring\u0026amp; operator\u0026lt;\u0026lt;(const signed char* s); fastring\u0026amp; operator\u0026lt;\u0026lt;(const unsigned char* s); template\u0026lt;typename T\u0026gt; fastring\u0026amp; operator\u0026lt;\u0026lt;(T\u0026amp;\u0026amp; t);   The first two versions are added in v2.0.3, which are equivalent to fastring\u0026amp; operator\u0026lt;\u0026lt;(const char* s).\n  In the third version, T can be any basic type (bool, char, int, double, void*, etc.), and string type (const char*, fastring, std::string).\n  For argument of string type, it can be the fastring itself or a part of it that performs the operator\u0026lt;\u0026lt; operation.\n  Example\n  fastring s; s \u0026lt;\u0026lt; false; // s -\u0026gt; \u0026#34;false\u0026#34; s \u0026lt;\u0026lt; s; // s -\u0026gt; \u0026#34;falsefalse\u0026#34; (append itself) s.clear(); s \u0026lt;\u0026lt; \u0026#34;hello \u0026#34; \u0026lt;\u0026lt; 23; // s -\u0026gt; \u0026#34;hello 23\u0026#34; s \u0026lt;\u0026lt; s.c_str() + 6; // s -\u0026gt; \u0026#34;hello 2323\u0026#34; (append part of s) s \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // s -\u0026gt; \u0026#34;hello 2323 \u0026#34; #fastring::operator+=\rfastring\u0026amp; operator+=(const char* s); fastring\u0026amp; operator+=(const fastring\u0026amp; s); fastring\u0026amp; operator+=(const std::string\u0026amp; s); fastring\u0026amp; operator+=(char c); fastring\u0026amp; operator+=(signed char c); fastring\u0026amp; operator+=(unsigned char c);   This method is equivalent to the append() method.\n  Example\n  fastring s; s += \u0026#39;c\u0026#39;; // s -\u0026gt; \u0026#34;c\u0026#34; s += \u0026#34;xx\u0026#34;; // s -\u0026gt; \u0026#34;cxx\u0026#34; #———————————\r#fastring::find\rsize_t find(char c) const; size_t find(char c, size_t pos) const; size_t find(const char* s) const; size_t find(const char* s, size_t pos) const;   The first version searches for the character c starting from position 0.\n  The second version looks for the character c starting at position pos.\n  The third version starts from position 0 to find the substring s, which is implemented internally based on strstr(), and does not apply to fastring containing \u0026lsquo;\\0\u0026rsquo;.\n  The fourth version is like the third but searchs from position pos.\n  This method returns the position of the character or substring when the search succeeds, otherwise it returns fastring::npos.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); s.find(\u0026#39;l\u0026#39;); // return 2 s.find(\u0026#39;l\u0026#39;, 3); // return 3 s.find(\u0026#34;ll\u0026#34;); // return 2 s.find(\u0026#34;ll\u0026#34;, 3); // return s.npos #fastring::rfind\rsize_t rfind(char c) const; size_t rfind(const char* s) const;   The first version searches for a single character in reverse. It is based on strrchr() and is not applicable to fastring containing \u0026lsquo;\\0\u0026rsquo;.\n  The second version searches for a substring in reverse.\n  This method returns the position of the character or substring when the search succeeds, otherwise it returns fastring::npos.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); s.rfind(\u0026#39;l\u0026#39;); // return 3 s.rfind(\u0026#34;ll\u0026#34;); // return 2 s.rfind(\u0026#34;le\u0026#34;); // return s.npos #fastring::find_first_of\rsize_t find_first_of(const char* s) const; size_t find_first_of(const char* s, size_t pos) const;   Find the first occurrence of a character in the specified character set.\n  The first version is searched from position 0.\n  The second version is searched from position pos.\n  This method is implemented based on strcspn() and is not suitable for fastring that contains \u0026lsquo;\\0\u0026rsquo;.\n  This method searches from the beginning, and when it encounters any character in s, it returns the position of the character, otherwise it returns fastring::npos.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); s.find_first_of(\u0026#34;def\u0026#34;); // return 1 s.find_first_of(\u0026#34;ol\u0026#34;, 3); // return 3 #fastring::find_first_not_of\rsize_t find_first_not_of(const char* s) const; size_t find_first_not_of(const char* s, size_t pos) const; size_t find_first_not_of(char s, size_t pos=0);   Find the first occurrence of a character not in the specified character set.\n  The first version is searched from position 0.\n  The second version is searched from position pos.\n  The third version of the character set is a single character, and s cannot be \u0026lsquo;\\0\u0026rsquo;.\n  This method is implemented based on strspn and is not suitable for fastring containing \u0026lsquo;\\0\u0026rsquo;.\n  This method searches from the beginning. When it encounters any character not in s, it returns the position of the character, otherwise it returns fastring::npos.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); s.find_first_not_of(\u0026#34;he\u0026#34;); // return 2 s.find_first_not_of(\u0026#34;he\u0026#34;, 3); // return 3 s.find_first_not_of(\u0026#39;x\u0026#39;); // return 0 #fastring::find_last_of\rsize_t find_last_of(const char* s, size_t pos=npos) const;   Find the last occurrence of a character in the specified character set.\n  The parameter pos in this method defaults to npos, which means searching from the end of fastring.\n  This method starts a reverse search from pos, and when it encounters any character in s, it returns the position of the character, otherwise it returns fastring::npos.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); s.find_last_of(\u0026#34;le\u0026#34;); // return 3 s.find_last_of(\u0026#34;le\u0026#34;, 1); // return 1 #fastring::find_last_not_of\rsize_t find_last_not_of(const char* s, size_t pos=npos) const; size_t find_last_not_of(char s, size_t pos=npos) const;   Find the last occurrence of a character not in the specified character set.\n  The parameter pos in this method defaults to npos, which means searching from the end of fastring.\n  In the second version, s is a single character, and s cannot be \u0026lsquo;\\0\u0026rsquo;.\n  This method starts a reverse search from pos, and when it encounters any character not in s, it returns the position of the character, otherwise it returns fastring::npos.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); s.find_last_not_of(\u0026#34;le\u0026#34;); // return 4 s.find_last_not_of(\u0026#34;le\u0026#34;, 3); // return 0 s.find_last_not_of(\u0026#39;o\u0026#39;); // return 3 #fastring::npos\rstatic const size_t npos = (size_t)-1;   npos is the maximum value of the size_t type.\n  When npos is used as the length, it means until the end of the string.\n  When npos is used as the return value, it means not found.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); size_t r = s.find(\u0026#39;x\u0026#39;); r == s.npos; // true #———————————\r#fastring::replace\rfastring\u0026amp; replace(const char* sub, const char* to, size_t maxreplace=0);   This method replaces the substring sub in fastring with to. The parameter maxreplace specifies the maximum number of replacements, and 0 means unlimited.\n  This method returns the fastring reference, and multiple replace operations can be written in one line.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); s.replace(\u0026#34;ll\u0026#34;, \u0026#34;rr\u0026#34;); // s -\u0026gt; \u0026#34;herro\u0026#34; s.replace(\u0026#34;err\u0026#34;, \u0026#34;ok\u0026#34;).replace(\u0026#34;k\u0026#34;, \u0026#34;o\u0026#34;); // s -\u0026gt; \u0026#34;hooo\u0026#34; #fastring::strip\rfastring\u0026amp; strip(const char* s=\u0026#34; \\t\\r\\n\u0026#34;, char d=\u0026#39;b\u0026#39;); fastring\u0026amp; strip(char s, char d=\u0026#39;b\u0026#39;);   Trim a string, removes specified characters on the left, right or both sides of fastring.\n  The parameter s is the characters to be trimmed, the parameter d represents the direction, \u0026rsquo;l\u0026rsquo; or \u0026lsquo;L\u0026rsquo; for left, \u0026lsquo;r\u0026rsquo; or \u0026lsquo;R\u0026rsquo; for right, and the default is \u0026lsquo;b\u0026rsquo; for both sides.\n  The first version removes blank characters on both sides of fastring by default.\n  In the second version, s is a single character, and s cannot be \u0026lsquo;\\0\u0026rsquo;.\n  Example\n  fastring s = \u0026#34;sos\\r\\n\u0026#34;; s.strip(); // s -\u0026gt; \u0026#34;sos\u0026#34; s.strip(\u0026#39;s\u0026#39;,\u0026#39;l\u0026#39;); // s -\u0026gt; \u0026#34;os\u0026#34; s.strip(\u0026#39;s\u0026#39;,\u0026#39;r\u0026#39;); // s -\u0026gt; \u0026#34;o\u0026#34; #fastring::tolower\rfastring\u0026amp; tolower();  This method converts fastring to lowercase and returns a reference to fastring.  #fastring::toupper\rfastring\u0026amp; toupper();  This method converts fastring to uppercase and returns a reference to fastring.  #fastring::lower\rfastring lower() const;  This method returns the lowercase form of fastring.  #fastring::upper\rfastring upper() const;   This method returns the uppercase form of fastring.\n  Example\n  fastring s(\u0026#34;Hello\u0026#34;); fastring x = s.lower(); // x = \u0026#34;hello\u0026#34;, s remains unchanged fastring y = s.upper(); // x = \u0026#34;HELLO\u0026#34;, s remains unchanged s.tolower(); // s -\u0026gt; \u0026#34;hello\u0026#34; s.toupper(); // s -\u0026gt; \u0026#34;HELLO\u0026#34; #———————————\r#fastring::clear\rvoid clear();  This method only sets the size of fastring to 0, and the capacity remains unchanged.  #fastring::ensure\rvoid ensure(size_t n);  This method ensures that the remaining memory of fastring can hold at least n characters.  #fastring::reserve\rvoid reserve(size_t n);  This method ensures that the capacity of fastring is at least n. When n is less than the original capacity, the capacity remains unchanged.  #fastring::reset\rvoid reset();  Added in v2.0.3. Clear fastring and free the memory.  #fastring::resize\rvoid resize(size_t n);   This method sets the size of fastring to n.\n  When n is greater than the original size, this operation will expand size to n, but will not fill the expanded part with \u0026lsquo;\\0\u0026rsquo;.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); s.resize(3); // s -\u0026gt; \u0026#34;hel\u0026#34; s.resize(6); char c = s[5]; // c is an uncertain random value #fastring::safe_clear\rvoid safe_clear();  Like the clear(), but it will fill in the internal memory with zeros.  #fastring::swap\rvoid swap(fastring\u0026amp; s) noexcept; void swap(fastring\u0026amp;\u0026amp; s) noexcept;   This method exchanges the contents of two fastrings, only the data pointer, capacity, and size are exchanged internally.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); fastring x(\u0026#34;world\u0026#34;); s.swap(x); // s -\u0026gt; \u0026#34;world\u0026#34;, x -\u0026gt; \u0026#34;hello\u0026#34; #———————————\r#fastring::starts_with\rbool starts_with(char s) const; bool starts_with(const char* s, size_t n) const; bool starts_with(const char* s) const; bool starts_with(const fastring\u0026amp; s) const; bool starts_with(const std::string\u0026amp; s) const;  This method determines whether fastring starts with s, and s is a single character or a string. When s is an empty string, this method always returns true.  #fastring::ends_with\rbool ends_with(char s) const; bool ends_with(const char* s, size_t n) const; bool ends_with(const char* s) const; bool ends_with(const fastring\u0026amp; s) const; bool ends_with(const std::string\u0026amp; s) const;  This method determines whether fastring ends with s, and s is a single character or a string. When s is an empty string, this method always returns true.  #fastring::match\rbool match(const char* pattern) const;   Check whether fastring matches the pattern, * matches any string, and ? matches a single character.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); s.match(\u0026#34;he??o\u0026#34;); // true s.match(\u0026#34;h*o\u0026#34;); // true s.match(\u0026#34;he?o\u0026#34;); // false s.match(\u0026#34;*o\u0026#34;); // true s.match(\u0026#34;h*l?\u0026#34;); // true #fastring::lshift\rfastring\u0026amp; lshift(size_t n);   This method shifts fastring to the left by n characters, which means removing the first n characters.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); s.lshift(2); // s -\u0026gt; \u0026#34;llo\u0026#34; s.lshift(8); // s -\u0026gt; \u0026#34;\u0026#34; #fastring::remove_tail\rfastring\u0026amp; remove_tail(const char* s, size_t n); fastring\u0026amp; remove_tail(const char* s); fastring\u0026amp; remove_tail(const fastring\u0026amp; s); fastring\u0026amp; remove_tail(const std::string\u0026amp; s);   This method deletes the string s at the end of fastring if the fastring ends with s.\n  Example\n  fastring s(\u0026#34;hello.log\u0026#34;); s.remove_tail(\u0026#34;.log\u0026#34;); // s -\u0026gt; \u0026#34;hello\u0026#34; #fastring::shrink\rvoid shrink();   This method releases the extra memory in fastring.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); s.reserve(32); // capacity -\u0026gt; 32 s.shrink(); // capacity -\u0026gt; 6 #global functions\r#operator+\rfastring operator+(const fastring\u0026amp; a, char b); fastring operator+(char a, const fastring\u0026amp; b); fastring operator+(const fastring\u0026amp; a, const fastring\u0026amp; b); fastring operator+(const fastring\u0026amp; a, const char* b); fastring operator+(const char* a, const fastring\u0026amp; b); fastring operator+(const fastring\u0026amp; a, const std::string\u0026amp; b); fastring operator+(const std::string\u0026amp; a, const fastring\u0026amp; b);   At least one parameter of this method is fastring.\n  Example\n  fastring s; s = s + \u0026#39;^\u0026#39;; // s -\u0026gt; \u0026#34;^\u0026#34; s = \u0026#34;o\u0026#34; + s + \u0026#34;o\u0026#34;; // s -\u0026gt; \u0026#34;o^o\u0026#34; #operator==\rbool operator==(const fastring\u0026amp; a, const fastring\u0026amp; b); bool operator==(const fastring\u0026amp; a, const char* b); bool operator==(const char* a, const fastring\u0026amp; b); bool operator==(const fastring\u0026amp; a, const std::string\u0026amp; b); bool operator==(const std::string\u0026amp; a, const fastring\u0026amp; b);  This method determines whether two strings are equal, at least one parameter is fastring.  #operator!=\rbool operator!=(const fastring\u0026amp; a, const fastring\u0026amp; b); bool operator!=(const fastring\u0026amp; a, const char* b); bool operator!=(const char* a, const fastring\u0026amp; b); bool operator!=(const fastring\u0026amp; a, const std::string\u0026amp; b); bool operator!=(const std::string\u0026amp; a, const fastring\u0026amp; b);  This method determines whether two strings are not equal, at least one parameter is fastring.  #operator\u0026lt;\rbool operator\u0026lt;(const fastring\u0026amp; a, const fastring\u0026amp; b); bool operator\u0026lt;(const fastring\u0026amp; a, const char* b); bool operator\u0026lt;(const char* a, const fastring\u0026amp; b); bool operator\u0026lt;(const fastring\u0026amp; a, const std::string\u0026amp; b); bool operator\u0026lt;(const std::string\u0026amp; a, const fastring\u0026amp; b);  This method determines whether the string a is less than b, and at least one parameter is fastring.  #operator\u0026gt;\rbool operator\u0026gt;(const fastring\u0026amp; a, const fastring\u0026amp; b); bool operator\u0026gt;(const fastring\u0026amp; a, const char* b); bool operator\u0026gt;(const char* a, const fastring\u0026amp; b); bool operator\u0026gt;(const fastring\u0026amp; a, const std::string\u0026amp; b); bool operator\u0026gt;(const std::string\u0026amp; a, const fastring\u0026amp; b);  This method determines whether the string a is greater than b, and at least one parameter is fastring.  #operator\u0026lt;=\rbool operator\u0026lt;=(const fastring\u0026amp; a, const fastring\u0026amp; b); bool operator\u0026lt;=(const fastring\u0026amp; a, const char* b); bool operator\u0026lt;=(const char* a, const fastring\u0026amp; b); bool operator\u0026lt;=(const fastring\u0026amp; a, const std::string\u0026amp; b); bool operator\u0026lt;=(const std::string\u0026amp; a, const fastring\u0026amp; b);  This method determines whether the string a is less than or equal to b. At least one parameter is fastring.  #operator\u0026gt;=\rbool operator\u0026gt;=(const fastring\u0026amp; a, const fastring\u0026amp; b); bool operator\u0026gt;=(const fastring\u0026amp; a, const char* b); bool operator\u0026gt;=(const char* a, const fastring\u0026amp; b); bool operator\u0026gt;=(const fastring\u0026amp; a, const std::string\u0026amp; b); bool operator\u0026gt;=(const std::string\u0026amp; a, const fastring\u0026amp; b);   This method determines whether the string a is greater than or equal to b, and at least one parameter is fastring.\n  Example\n  fastring s(\u0026#34;hello\u0026#34;); s == \u0026#34;hello\u0026#34;; // true s != \u0026#34;hello\u0026#34;; // false s \u0026gt; \u0026#34;aa\u0026#34;; // true s \u0026lt; \u0026#34;xx\u0026#34;; // true s \u0026gt;= \u0026#34;he\u0026#34;; // true s \u0026lt;= \u0026#34;he\u0026#34;; // false #operator\u0026laquo;\rstd::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const fastring\u0026amp; s);  Example  fastring s(\u0026#34;xx\u0026#34;); std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; std::endl; "},{"id":6,"href":"/en/co/fastream/","title":"fastream","section":"Documents for CO","content":"include: co/fastream.h.\n#fastream\rfastream is used to replace std::ostringstream in the C++ standard library. The performance of std::ostringstream is poor which may be several times slower than snprintf, and fastream is about 10~30 times faster than snprintf on different platforms.\n#fastream::fastream\rfastream() noexcept; explicit fastream(size_t cap); fastream(fastream\u0026amp;\u0026amp; s) noexcept;   The first one is the default constructor, which creates an empty fastream object without any memory allocation.\n  The second constructor uses the parameter cap to specify the initial capacity of fastream.\n  The third is the move constructor.\n  Example\n  fastream s; // fastream with empty status, no memory allocated fastream s(1024); // Pre-allocate 1k memory fastream x(std::move(s); // move constructor, s becomes an empty object #fastream::operator=\rfastream\u0026amp; operator=(fastream\u0026amp;\u0026amp; s) noexcept;   Move assignment, the content of s is transferred to fastream, and s itself becomes an empty object.\n  Example\n  fastream s(32); fastream x; x = std::move(s); // x capacity -\u0026gt; 32, s -\u0026gt; empty #———————————\r#fastream::back\rchar\u0026amp; back() const;   This method returns a reference to the last character in fastream.\n  If fastream is empty, calling this method will cause undefined behavior.\n  Example\n  fastream s; s.append(\u0026#34;hello\u0026#34;); char c = s.back(); // c =\u0026#39;o\u0026#39; s.back() =\u0026#39;x\u0026#39;; // s -\u0026gt; \u0026#34;hellx\u0026#34; #fastream::front\rchar\u0026amp; front() const;   This method returns a reference to the first character in fastream.\n  If fastream is empty, calling this method will cause undefined behavior.\n  Example\n  fastream s; s.append(\u0026#34;hello\u0026#34;); char c = s.front(); // c =\u0026#39;h\u0026#39; s.front() =\u0026#39;x\u0026#39;; // s -\u0026gt; \u0026#34;xello\u0026#34; #fastream::operator[]\rchar\u0026amp; operator[](size_t n) const;   This method returns the reference of the nth character in fastream.\n  If n is out of a reasonable range, calling this method will cause undefined behavior.\n  Example\n  fastream s; s.append(\u0026#34;hello\u0026#34;); char c = s[1]; // c =\u0026#39;e\u0026#39; s[1] =\u0026#39;x\u0026#39;; // s -\u0026gt; \u0026#34;hxllo\u0026#34; #———————————\r#fastream::capacity\rsize_t capacity() const;  This method returns the capacity of fastream.  #fastream::c_str\rconst char* c_str() const;  This method gets the equivalent C string. This method adds a \u0026lsquo;\\0\u0026rsquo; to the end of fastream, it will not change the size and content of fastream, but may cause internal reallocation of memory.  #fastream::data\rconst char* data() const;  This method is similar to c_str(), but it does not guarantee that the string ends with \u0026lsquo;\\0\u0026rsquo;.  #fastream::empty\rbool empty() const;  This method determines whether fastream is empty.  #fastream::size\rsize_t size() const;  This method returns the length of data in fastream.  #fastream::str\rfastring str() const;   This method returns a copy of fastream\u0026rsquo;s internal data in the form of fastring.\n  Example\n  fastream s; s.append(\u0026#34;hello\u0026#34;); fastring x = s.str(); // x = \u0026#34;hello\u0026#34; #———————————\r#fastream::append\r1. fastream\u0026amp; append(const void* s, size_t n); 2. fastream\u0026amp; append(const char* s); 3. fastream\u0026amp; append(const fastring\u0026amp; s); 4. fastream\u0026amp; append(const std::string\u0026amp; s); 5. fastream\u0026amp; append(const fastream\u0026amp; s); 6. fastream\u0026amp; append(size_t n, char c); 7. fastream\u0026amp; append(char c, size_t n); 8. fastream\u0026amp; append(char c); 9. fastream\u0026amp; append(signed char v) 10. fastream\u0026amp; append(unsigned char c); 11. fastream\u0026amp; append(short v); 12. fastream\u0026amp; append(unsigned short v); 13. fastream\u0026amp; append(int v); 14. fastream\u0026amp; append(unsigned int v); 15. fastream\u0026amp; append(long v); 16. fastream\u0026amp; append(unsigned long v); 17. fastream\u0026amp; append(long long v); 18. fastream\u0026amp; append(unsigned long long v);   The first version appends a byte sequence of length n.\n  The second version appends a C string. Unlike fastring, fastream does not check whether the memory overlaps, and s cannot be part of the fastream performing the append operation.\n  The 3rd and 4th versions appends fastring and std::string respectively.\n  The 5th version appends fastream, s can be the fastream performing the append operation.\n  The 6th and 7th versions appends n characters c.\n  The 8th to 10th versions appends a single character c.\n  The 11th to 18th versions appends 8 built-in integer types in binary form, which is equivalent to append(\u0026amp;v, sizeof(v)).\n  Example\n  fastream s; int32 i = 7; char buf[8];  s.append(\u0026#34;xx\u0026#34;); // Append C string s.append(s); // append itself, s -\u0026gt; \u0026#34;xxxx\u0026#34; s.append(buf, 8); // Append 8 bytes s.append(\u0026#39;c\u0026#39;); // Append a single character s.append(100,\u0026#39;c\u0026#39;); // Append 100\u0026#39;c\u0026#39; s.append(\u0026#39;c\u0026#39;, 100); // append 100\u0026#39;c\u0026#39;  s.append(\u0026amp;i, 4); // Append 4 bytes s.append(i); // Append 4 bytes, same as above s.append((int16)23); // Append 2 bytes  // The following usage is wrong and unsafe s.append(s.c_str() + 1); #fastream::cat\rtemplate\u0026lt;typename X, typename ...V\u0026gt; fastream\u0026amp; cat(X\u0026amp;\u0026amp; x, V\u0026amp;\u0026amp; ... v);   Added in v2.0.3. Concatenate any number of elements to fastream.\n  This method appends elements in the parameters to fastream one by one through operator\u0026lt;\u0026lt;.\n  Example\n  fastream s; s \u0026lt;\u0026lt; \u0026#34;hello\u0026#34;; s.cat(\u0026#39;\u0026#39;, 23, \u0026#34;xx\u0026#34;, false); // s -\u0026gt; \u0026#34;hello 23xxfalse\u0026#34; #fastream::operator\u0026laquo;\rfastream\u0026amp; operator\u0026lt;\u0026lt;(const signed char* s); fastream\u0026amp; operator\u0026lt;\u0026lt;(const unsigned char* s); template\u0026lt;typename T\u0026gt; fastream\u0026amp; operator\u0026lt;\u0026lt;(T\u0026amp;\u0026amp; t);   The first two versions are added in v2.0.3, which are equivalent to fastream\u0026amp; operator\u0026lt;\u0026lt;(const char* s).\n  In the third version, T can be any basic type (bool, char, int, double, void*, etc.), string type (const char*, fastring, std::string) or fastream.\n  Unlike fastring, fastream does not perform memory security checks, operations like s \u0026lt;\u0026lt; s.c_str() + 3; are not safe.\n  Example\n  fastream s; s \u0026lt;\u0026lt; false; // s -\u0026gt; \u0026#34;false\u0026#34; s.clear(); s \u0026lt;\u0026lt; \u0026#34;hello \u0026#34;\u0026lt;\u0026lt; 23; // s -\u0026gt; \u0026#34;hello 23\u0026#34; s \u0026lt;\u0026lt; \u0026#39;\u0026#39;; // s -\u0026gt; \u0026#34;hello 23 \u0026#34; s \u0026lt;\u0026lt; s; // s -\u0026gt; \u0026#34;hello 23 hello 23 \u0026#34; #———————————\r#fastream::clear\rvoid clear();  This method only sets the size of fastream to 0, and the capacity remains unchanged.  #fastream::ensure\rvoid ensure(size_t n);  This method ensures that the remaining memory of fastream can hold at least n characters.  #fastream::reset\rvoid reset();  Added in v2.0.3. Clear fastream and free the memory.  #fastream::reserve\rvoid reserve(size_t n);  This method adjusts the capacity of fastream to ensure that the capacity is at least n.  #fastream::resize\rvoid resize(size_t n);   This method sets the size of fastream to n.\n  When n is greater than the original size, this operation will expand size to n, but will not fill the expanded part with \u0026lsquo;\\0\u0026rsquo;.\n  Example\n  fastream s; s.append(\u0026#34;hello\u0026#34;); s.resize(3); // s -\u0026gt; \u0026#34;hel\u0026#34; s.resize(6); char c = s[5]; // c is an uncertain random value #fastream::safe_clear\rvoid safe_clear();  Like the clear(), but will fill the internal memory with zeros.  #fastream::swap\rvoid swap(fastream\u0026amp; s) noexcept; void swap(fastream\u0026amp;\u0026amp; s) noexcept;   This method exchanges the contents of two fastreams, only the internal pointer, capacity, and size are exchanged.\n  Example\n  fastream s(32); fastring x(64); s.swap(x); // s: cap -\u0026gt; 64, x: cap -\u0026gt; 32 #———————————\r#Interoperability with fastring\rfastream and fastring are both inherited from fast::stream, the memory structure of them is exactly the same, so they can be easily converted to each other:\nfastream s; s.append(\u0026#34;Hello\u0026#34;); ((fastring*)\u0026amp;s)-\u0026gt;tolower(); // s -\u0026gt; \u0026#34;hello\u0026#34;  fastring x; void f(fastream\u0026amp;); f(*(fastream*)\u0026amp;x); As mentioned earlier, the append operation of fastream will not check memory overlap. If necessary, it can be converted to fastring to perform the operation safely:\nfastream s; s.append(\u0026#34;hello\u0026#34;); ((fastring*)\u0026amp;s)-\u0026gt;append(s.c_str() + 1); "},{"id":7,"href":"/en/about/sponsor/","title":"Sponsor💕","section":"About","content":"#Sponsor\rCO is a personal project. If you are interested in sponsoring CO, you can contact with Alvin (idealvin@qq.com), we\u0026rsquo;ll display your logo, website and other information here, and also provide you with better technical services. Thank you very much🙏\n  Github Sponsor\n\r  #Special sponsors\rCO is specially sponsored by the following companies, thank you very much!\n\r#Coffee\rIf you like CO, you may also buy the author a cup of coffee, thanks🙏\n  Paypal\nidealvin@qq.com\n  Wechat\n  Alipay\n  "},{"id":8,"href":"/en/co/str/","title":"String utilities","section":"Documents for CO","content":"include: co/str.h.\n#split, strip, replace,\r#str::split\rstd::vector\u0026lt;fastring\u0026gt; split(const char* s, char c, uint32 n=0); std::vector\u0026lt;fastring\u0026gt; split(const fastring\u0026amp; s, char c, uint32 n=0); std::vector\u0026lt;fastring\u0026gt; split(const char* s, const char* c, uint32 n=0); std::vector\u0026lt;fastring\u0026gt; split(const fastring\u0026amp; s, const char* c, uint32 n=0);   This function splits the string into several substrings, the original string remains unchanged, and returns the split result.\n  Parameter s is a C string or fastring, parameter c is the separator, parameter n is the maximum number of splits, 0 or -1 means unlimited.\n  In the fourth version, s cannot contain \u0026lsquo;\\0\u0026rsquo;, because the internal implementation uses strstr() to search for substrings.\n  Example\n  str::split(\u0026#34;x y z\u0026#34;, \u0026#39;\u0026#39;); // -\u0026gt; [\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;] str::split(\u0026#34;|x|y|\u0026#34;,\u0026#39;|\u0026#39;); // -\u0026gt; [\u0026#34;\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;] str::split(\u0026#34;xooy\u0026#34;, \u0026#34;oo\u0026#34;); // -\u0026gt; [\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;] str::split(\u0026#34;xooy\u0026#34;,\u0026#39;o\u0026#39;); // -\u0026gt; [\u0026#34;x\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;y\u0026#34;] str::split(\u0026#34;xooy\u0026#34;,\u0026#39;o\u0026#39;, 1); // -\u0026gt; [\u0026#34;x\u0026#34;, \u0026#34;oy\u0026#34;] #str::strip\rfastring strip(const char* s, const char* c=\u0026#34; \\t\\r\\n\u0026#34;, char d=\u0026#39;b\u0026#39;); fastring strip(const fastring\u0026amp; s, const char* c=\u0026#34; \\t\\r\\n\u0026#34;, char d=\u0026#39;b\u0026#39;); fastring strip(const char* s, char c, char d =\u0026#39;b\u0026#39;); fastring strip(const fastring\u0026amp; s, char c, char d=\u0026#39;b\u0026#39;); fastring strip(const fastring\u0026amp; s, const fastring\u0026amp; c, char d=\u0026#39;b\u0026#39;);   This function removes the specified characters on the left or right sides of the string, the original string remains unchanged, and the result after strip is returned.\n  The parameter s is a C string or fastring, the parameter c is the character set to be removed, the parameter d is the direction, \u0026rsquo;l\u0026rsquo; or \u0026lsquo;L\u0026rsquo; for left side, \u0026lsquo;r\u0026rsquo; or \u0026lsquo;R\u0026rsquo; for right side, and the default is \u0026lsquo;b\u0026rsquo; means both sides.\n  The first and second versions remove the blank characters on both sides of the string by default.\n  In the 3rd and 4th versions, c is a single character.\n  Example\n  str::strip(\u0026#34; xx\\r\\n\u0026#34;); // -\u0026gt; \u0026#34;xx\u0026#34; str::strip(\u0026#34;abxxa\u0026#34;, \u0026#34;ab\u0026#34;); // -\u0026gt; \u0026#34;xx\u0026#34; str::strip(\u0026#34;abxxa\u0026#34;, \u0026#34;ab\u0026#34;,\u0026#39;l\u0026#39;); // -\u0026gt; \u0026#34;xxa\u0026#34; str::strip(\u0026#34;abxxa\u0026#34;, \u0026#34;ab\u0026#34;,\u0026#39;r\u0026#39;); // -\u0026gt; \u0026#34;abxx\u0026#34; #str::replace\rfastring replace(const char* s, const char* sub, const char* to, uint32 n=0); fastring replace(const fastring\u0026amp; s, const char* sub, const char* to, uint32 n=0);   This function is used to replace substrings in the string, the original string remains unchanged, and the replaced result is returned.\n  Parameter s is a C string or fastring, substring sub in s will be replaced with to. Parameter n is the maximum number of replacements, 0 or -1 means unlimited.\n  In the second version, s cannot contain \u0026lsquo;\\0\u0026rsquo;, because the internal implementation uses strstr() to search for substrings.\n  Example\n  str::replace(\u0026#34;xooxoox\u0026#34;, \u0026#34;oo\u0026#34;, \u0026#34;ee\u0026#34;); // -\u0026gt; \u0026#34;xeexeex\u0026#34; str::replace(\u0026#34;xooxoox\u0026#34;, \u0026#34;oo\u0026#34;, \u0026#34;ee\u0026#34;, 1); // -\u0026gt; \u0026#34;xeexoox\u0026#34; #str::cat\rtemplate \u0026lt;typename ...X\u0026gt; inline fastring cat(X\u0026amp;\u0026amp; ... x);   Added in v2.0.3. Concatenate any number of elements to make a string.\n  This function concatenates elements in the parameters to the string one by one through operator\u0026lt;\u0026lt;.\n  示例\n  // s -\u0026gt; \u0026#34;hello 23true\u0026#34; fastring s = str::cat(\u0026#34;hello\u0026#34;, \u0026#39; \u0026#39;, 23, true); #Convert string to built-in type\r#str::to_bool\rbool to_bool(const char* s); bool to_bool(const fastring\u0026amp; s); bool to_bool(const std::string\u0026amp; s);   This function converts a string to bool type.\n  When s is equal to \u0026ldquo;0\u0026rdquo; or \u0026ldquo;false\u0026rdquo;, false is returned; when s is equal to \u0026ldquo;1\u0026rdquo; or \u0026ldquo;true\u0026rdquo;, true is returned.\n  This functions returns false on error, and the errno will be EINVAL.\n  Example\n  bool b = str::to_bool(\u0026#34;true\u0026#34;); // x = true bool x = str::to_bool(\u0026#34;false\u0026#34;); // x = false #str::to_double\rdouble to_double(const char* s); double to_double(const fastring\u0026amp; s); double to_double(const std::string\u0026amp; s);   This function converts a string to double type.\n  This functions returns 0 on error, and the errno will be ERANGE or EINVAL.\n  Example\n  double x = str::to_double(\u0026#34;3.14\u0026#34;); // x = 3.14 #str::to_int\rint32 to_int32(const char* s); int32 to_int32(const fastring\u0026amp; s); int32 to_int32(const std::string\u0026amp; s); int64 to_int64(const char* s); int64 to_int64(const fastring\u0026amp; s); int64 to_int64(const std::string\u0026amp; s); uint32 to_uint32(const char* s); uint32 to_uint32(const fastring\u0026amp; s); uint32 to_uint32(const std::string\u0026amp; s); uint64 to_uint64(const char* s); uint64 to_uint64(const fastring\u0026amp; s); uint64 to_uint64(const std::string\u0026amp; s);   These functions convert a string to integer types.\n  The parameter s can take an unit k, m, g, t, p at the end, which is not case sensitive.\n  These functions return 0 on error, and the errno will be ERANGE or EINVAL.\n  Example\n  int32 i32; int64 i64; uint32 u32; uint64 u64;  i32 = str::to_int32(\u0026#34;-23\u0026#34;); // -23 u32 = str::to_uint32(\u0026#34;4k\u0026#34;); // 4096 i64 = str::to_int32(\u0026#34;8M\u0026#34;); // 8 \u0026lt;\u0026lt; 20 i64 = str::to_int64(\u0026#34;8T\u0026#34;); // 8ULL \u0026lt;\u0026lt; 40 u64 = str::to_int64(\u0026#34;1P\u0026#34;); // 1ULL \u0026lt;\u0026lt; 50  i32 = str::to_int32(\u0026#34;8g\u0026#34;); LOG \u0026lt;\u0026lt; (i32 == 0); LOG \u0026lt;\u0026lt; (errno == ERANGE);  i32 = str::to_int32(\u0026#34;abx\u0026#34;); LOG \u0026lt;\u0026lt; (i32 == 0); LOG \u0026lt;\u0026lt; (errno == EINVAL); #Convert built-in types to string\r#str::from\rtemplate\u0026lt;typename T\u0026gt; inline fastring from(T t);   This function converts built-in types to a string.\n  T can be any built-in type, such as bool, int, double, void*, etc.\n  Example\n  fastring s; s = str::from(true); // -\u0026gt; \u0026#34;true\u0026#34; s = str::from(23); // -\u0026gt; \u0026#34;23\u0026#34; s = str::from(3.14); // -\u0026gt; \u0026#34;3.14\u0026#34; #Convert STL container to debug string\r#str::dbg\rtemplate\u0026lt;typename T\u0026gt; fastring dbg(const std::vector\u0026lt;T\u0026gt;\u0026amp; v); template\u0026lt;typename T\u0026gt; fastring dbg(const std::set\u0026lt;T\u0026gt;\u0026amp; v); template\u0026lt;typename T\u0026gt; fastring dbg(const std::unordered_set\u0026lt;T\u0026gt;\u0026amp; v) template\u0026lt;typename K, typename V\u0026gt; fastring dbg(const std::map\u0026lt;K, V\u0026gt;\u0026amp; v); template\u0026lt;typename K, typename V\u0026gt; fastring dbg(const std::unordered_map\u0026lt;K, V\u0026gt;\u0026amp; v);   This function converts a container to a debug string, which is generally for printing logs.\n  Example\n  std::vector\u0026lt;int\u0026gt; v {1, 2, 3 }; std::set\u0026lt;int\u0026gt; s {1, 2, 3 }; std::map\u0026lt;int, int\u0026gt; m {{1, 1}, {2, 2} }; str::dbg(v); // -\u0026gt; \u0026#34;[1,2,3]\u0026#34; str::dbg(s); // -\u0026gt; \u0026#34;{1,2,3}\u0026#34; str::dbg(m); // -\u0026gt; \u0026#34;{1:1,2:2} "},{"id":9,"href":"/en/co/flag/","title":"co/flag","section":"Documents for CO","content":"include: co/flag.h.\n#Basic concepts\rco/flag is a command line and config file parsing library similar to google gflags. Its principle is very simple, define global variables in code, then parse the command line parameters or config file when the program starts, and update the value of these global variables.\n#flag variable\rThe global variable defined by macros in co/flag are called flag variable. For example, the following code defines a flag variable, the variable name is FLG_x.\nDEF_bool(x, false, \u0026#34;xxx\u0026#34;); // bool FLG_x = false; co/flag supports 7 types of flag variable:\nbool, int32, int64, uint32, uint64, double, string Every flag variable has a default value, and a new value can be passed to it from command-line or config file. Take the previously FLG_x as an example, we can use -x=true in command line, or x = true in the config file, to set a new value for it.\n#command line flag\rCommand line parameters appear in the form of -x=y, where x is called a command line flag (hereinafter referred to as flag). The flag x in command line corresponds to the global variable FLG_x in the code, and -x=y in command line is equivalent to setting the value of FLG_x to y.\nco/flag is designed to be very flexible:\n  -x=y can omit the preceding -, abbreviated as x=y.\n  -x=y can also be written as -x y.\n  x=y can be preceded by any number of -.\n  For bool type flags, -b=true can be abbreviated as -b.\n  Example\n  # b, i, s are all flags, xx is not a flag ./exe -b -i=32 -s=hello xx #Initialization (flag::init)\rstd::vector\u0026lt;fastring\u0026gt; init(int argc, const char** argv); std::vector\u0026lt;fastring\u0026gt; init(int argc, char** argv); void init(const fastring\u0026amp; path);   The first 2 init functions, parse the command line parameters and config file, and update value of the flag variables. It usually needs to be called once at the beginning of the main function. Generally speaking, it does the following steps:\n Preprocess the command line parameters, the value of FLG_config may be updated then. If FLG_config is not empty, parse the config file specified by it, and update value of the flag variables. Parse other command line parameters and update value of the flag variables. If FLG_mkconf is true, generate a config file and terminate the program. If FLG_daemon is true, run the program as a daemon (for Linux only). When any error occurs, print the error message and terminate the program immediately. If no error occurs, return the non-flag list. For example, when executing ./exe x y, this function will return [\u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;].    The third init function, parses the config file and updates value of the flag variables. The parameter path is the path of the config file. When any error occurs, print the error message and terminate the program.\n  Example\n  #include \u0026#34;co/flag.h\u0026#34; int main(int argc, char** argv) {  flag::init(argc, argv); } #Use flag variable in the code\r#Define a flag variable\r#define DEF_bool(name, value, help) _DEFINE_FLAG(bool, name, value, help) #define DEF_int32(name, value, help) _DEFINE_FLAG(int32, name, value, help) #define DEF_int64(name, value, help) _DEFINE_FLAG(int64, name, value, help) #define DEF_uint32(name, value, help) _DEFINE_FLAG(uint32, name, value, help) #define DEF_uint64(name, value, help) _DEFINE_FLAG(uint64, name, value, help) #define DEF_double(name, value, help) _DEFINE_FLAG(double, name, value, help) #define DEF_string(name, value, help) _DEFINE_FLAG(string, name, value, help)   The above 7 macros are used to define 7 different types of flag variables.\n  The parameter name is the flag name, the corresponding global variable name is FLG_name, the parameter value is the default value, and the parameter help is comment for the flag.\n  A flag variable is a global variable and generally should not be defined in the header file.\n  The name of the flag variable is unique, and we cannot define two flag variables with the same name.\n  The flag variable is generally defined outside the namespace, otherwise it may be not possible to use FLG_name to access the flag variable.\n  Example\n  DEF_bool(b, false, \u0026#34;comments\u0026#34;); // bool FLG_b = false; DEF_int32(i32, 32, \u0026#34;comments\u0026#34;); // int32 FLG_i32 = 32; DEF_int64(i64, 64, \u0026#34;comments\u0026#34;); // int64 FLG_i64 = 64; DEF_uint32(u32, 0, \u0026#34;comments\u0026#34;); // uint32 FLG_u32 = 0; DEF_uint64(u64, 0, \u0026#34;comments\u0026#34;); // uint64 FLG_u64 = 0; DEF_double(d, 2.0, \u0026#34;comments\u0026#34;); // double FLG_d = 2.0; DEF_string(s, \u0026#34;x\u0026#34;, \u0026#34;comments\u0026#34;); // fastring FLG_s = \u0026#34;x\u0026#34;; #Declare the flag variable\r#define DEC_bool(name) _DECLARE_FLAG(bool, name) #define DEC_int32(name) _DECLARE_FLAG(int32, name) #define DEC_int64(name) _DECLARE_FLAG(int64, name) #define DEC_uint32(name) _DECLARE_FLAG(uint32, name) #define DEC_uint64(name) _DECLARE_FLAG(uint64, name) #define DEC_double(name) _DECLARE_FLAG(double, name) #define DEC_string(name) _DECLARE_FLAG(string, name)   The 7 macros above are used to declare 7 different types of flag variables.\n  The parameter name is the flag name, and the corresponding global variable name is FLG_name.\n  A flag variable can be defined only once, but it can be declared multiple times, which can be declared wherever needed.\n  The flag variable is generally declared outside the namespace, otherwise it may be not possible to use FLG_name to access the flag variable.\n  Example\n  DEC_bool(b); // extern bool FLG_b; DEC_int32(i32); // extern int32 FLG_i32; DEC_int64(i64); // extern int64 FLG_i64; DEC_uint32(u32); // extern uint32 FLG_u32; DEC_uint64(u64); // extern uint64 FLG_u64; DEC_double(d); // extern double FLG_d; DEC_string(s); // extern fastring FLG_s; #Use the flag variable\rOnce a flag variable is defined or declared, we can use it the same as an ordinary variable.\n#include \u0026#34;co/flag.h\u0026#34; DEC_bool(b); DEF_string(s, \u0026#34;hello\u0026#34;, \u0026#34;xxx\u0026#34;);  int main(int argc, char** argv) {  flag::init(argc, argv);   if (!FLG_b) std::cout \u0026lt;\u0026lt; \u0026#34;b is false\u0026#34; \u0026lt;\u0026lt; std::endl;  FLG_s += \u0026#34; world\u0026#34;;  std::cout \u0026lt;\u0026lt; FLG_s \u0026lt;\u0026lt; std::endl;   return 0; } #Use flag in the command line\r#Set value of flag variables\rSuppose the following flags are defined in the program:\nDEF_bool(x, false, \u0026#34;bool x\u0026#34;); DEF_bool(y, false, \u0026#34;bool y\u0026#34;); DEF_int32(i, -32, \u0026#34;int32\u0026#34;); DEF_uint64(u, 64, \u0026#34;uint64\u0026#34;); DEF_string(s, \u0026#34;nice\u0026#34;, \u0026#34;string\u0026#34;); When the program starts, we can modify value of the flag variables through command line parameters:\n# -x=y, x=y, -x y, the three are equivalent ./xx -i=8 u=88 -s=xxx ./xx -i 8 -u 88 -s \u0026#34;hello world\u0026#34; ./xx -i8 # -i=8, only for single-letter named integer flags  # When a bool type is set to true, the value can be omitted ./xx -x # -x=true  # Multiple single-letter named bool flags can be combined and set to true ./xx -xy # -x=true -y=true  # Integer type flags can have units k, m, g, t, p, not case sensitive ./xx -i -4k # i=-4096  # Integer type flags can pass octal or hexadecimal numbers ./xx i=032 # i=26 octal ./xx u=0xff # u=255 hexadecimal #List Help Information\rco/flag supports using --help command to print the help information of the program:\n$ ./xx --help usage:  ./xx - print flags info  ./xx --help print this help info  ./xx --mkconf generate config file  ./xx --daemon run as a daemon (Linux)  ./xx xx.conf run with config file  ./xx config=xx.conf run with config file  ./xx -x -i=8k -s=ok run with commandline flags  ./xx -x -i 8k -s ok run with commandline flags  ./xx x=true i=8192 s=ok run with commandline flags #List all flags\rco/flag provides -- command to list all the flags defined in the program:\n$ ./xx -- --config: .path of config file \ttype: string default: \u0026#34;\u0026#34; \tfrom: ../../base/flag.cc --mkconf: .generate config file \ttype: bool default: false \tfrom: ../../base/flag.cc #config file\r#config file format\rThe config file format of co/flag is flexible:\n  One config item per line, each config item corresponds to a flag, and the form is unified as x = y, which looks clear at a glance.\n  # or // are for comments.\n  # or // in quotation marks are not comments.\n  Ignore the blank characters at the beginning or end of the line.\n  Blank characters can be added before or after the = sign.\n  \\ can be used to continue a line to avoid too long a line.\n  The string does not support escaping to avoid ambiguity.\n  The string can be enclosed in double quotes, single quotes or 3 back quotes.\n  Sample config file\n  # config file: xx.confboo = true # bool types = # empty strings = hello \\world # s = \u0026#34;helloworld\u0026#34;s = \u0026#34;http://github.com\u0026#34; ## or // in quotation marks are not commentss = \u0026#34;I\u0026#39;m ok\u0026#34; # enclose the string in double quotess =\u0026#39;how are \u0026#34;U\u0026#34;\u0026#39; # enclose the string in single quotess = ```I\u0026#39;m \u0026#34;ok\u0026#34;``` # enclose the string in 3 back quotesi32 = 4k # 4096, integers can have units k, m, g, t, p, not case sensitivei32 = 032 # octal, i32 = 26i32 = 0xff # hexadecimal, i32 = 255pi = 3.14159 # double type#Generate config file\rDEF_bool(mkconf, false, \u0026#34;.generate config file\u0026#34;);  mkconf is a flag defined internally in co/flag, which is a switch for automatically generating config file. You can use -mkconf to generate a config file in command line.  ./xx -mkconf # Generate xx.conf ./xx -mkconf -x u=88 # Custom config item value #Adjust the order of config items in config file\rIn the automatically generated config file, the config items are sorted by flag level, file name, and code line number. If the user wants some config items to be ranked higher, the flag level can be set to a smaller value, otherwise, the flag level can be set to a larger value.\nWhen defining a flag, you can use #n at the beginning of the comment to specify the flag level, n must be an integer between 0 and 99. If the comment is not empty, there must be a space after n. When not specified, the default flag level is 10.\nDEF_bool(x, false, \u0026#34;comments\u0026#34;); // The default level is 10 DEF_bool(y, false, \u0026#34;#23\u0026#34;); // The level is 23, and the comment is empty DEF_bool(z, false, \u0026#34;#3 comments\u0026#34;); // The level is 3 #Prohibit config items from being generated in the config file\rFlags beginning with ., are hidden flags, which will not be present in the config file, but can be found with the -- command in command line. A flag with an empty comment is completely invisible and will neither be generated in the config file nor be found with the -- command.\nDEF_bool(x, false, \u0026#34;.say something here\u0026#34;); DEF_string(s, \u0026#34;good\u0026#34;, \u0026#34;\u0026#34;); #Specify the config file when the program starts\rDEF_string(config, \u0026#34;\u0026#34;, \u0026#34;.path of config file\u0026#34;);  config is a flag defined internally in co/flag, which is the path of the config file. You can use -config to specify the config file in command line. Another way, you can modify the value of FLG_config to specify the config file, before calling flag::init().  ./xx -config xx.conf  # If the config file name ends with .conf or config,  # and it is the first non-flag parameter in command line,  # -config can be omitted. ./xx xx.conf ./xx xx.conf -x #Custom help information\rDEF_string(help, \u0026#34;\u0026#34;, \u0026#34;.help info\u0026#34;);   help is a flag defined in co/flag, which stores the help information of the program. This information can be seen with the command --help in command line.\n  FLG_help is empty by default, and the default help information provided by co/flag is used.\n  You can modify the value of FLG_help before calling flag::init() to customize the help information.\n  Example\n  #include \u0026#34;co/flag.h\u0026#34; int main(int argc, char** argv) {  FLG_help \u0026lt;\u0026lt; \u0026#34;usage:\\n\u0026#34;  \u0026lt;\u0026lt; \u0026#34;\\t./xx -ip 127.0.0.1 -port 7777\\n\u0026#34;;  flag::init(argc, argv);  return 0; } #Run program as a daemon\rDEF_bool(daemon, false, \u0026#34;#0 run program as a daemon\u0026#34;);   daemon is a flag defined in co/flag. If it is true, the program will run as a daemon. It only works on Linux platform.\n  You can use -daemon in command line to make the program run in the background as a daemon.\n  Example\n  ./xx -daemon "},{"id":10,"href":"/en/co/log/","title":"co/log","section":"Documents for CO","content":"include: co/log.h.\n#Basic introduction\rco/log is a C++ streaming log library similar to google glog, which prints logs like this:\nLOG \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; 23; co/log divides logs into five levels: debug, info, warning, error, fatal, and provides a series of macros for printing logs of different levels. Printing the fatal level log will terminate the program, and co/log will also print the stack information before the program exits.\nco/log uses an asynchronous implementation. The log is first written to the cache, and after a certain amount or more than a certain period of time, the background thread writes all data in the cache to the file at a time. The performance is improved by about 20 to 150 times compared with glog on different platforms. The following table shows the test results of printing 1 million info logs (about 50 bytes each) by a single-thread on different platforms:\n   log vs glog google glog co/log     win2012 HHD 1.6MB/s 180MB/s   win10 SSD 3.7MB/s 560MB/s   mac SSD 17MB/s 450MB/s   linux SSD 54MB/s 1023MB/s    #Initialize and close the log system\r#log::init\rvoid init();   This function initializes the log library and starts the log thread. It needs to be called once at the beginning of the main function.\n  This function adds multi-thread protection internally, and it is safe to call this function multiple times.\n  co/log depends on co/flag, you need to call flag::init() before calling this function.\n  Example\n  #include \u0026#34;co/flag.h\u0026#34;#include \u0026#34;co/log.h\u0026#34; int main(int argc, char** argv) {  flag::init(argc, argv);  log::init(); } #log::exit\rvoid exit();  The above 2 functions are equal, which write logs in the cache to a file and exit the log thread. When the program exits normally, co/log will automatically call this function. It is safe to call this function multiple times. co/log internally captures signals such as SIGINT, SIGTERM, SIGQUIT, and calls this function before the program exits.  #log::close\rvoid close();  The same as log::exit().  #log::set_write_cb\rvoid set_write_cb(const std::function\u0026lt;void(const void*, size_t)\u0026gt;\u0026amp; cb);  By default, co/log writes logs to a local file. Users can set a callback to write logs to different destinations through this API. The callback has 2 parameters, a pointer to the log buffer and its length. The buffer may contain more than one logs. Once a callback is set, co/log will stop writing logs to the local file, which can be changed by setting the config item also_log_to_local to true.  #log::set_single_write_cb\rvoid set_single_write_cb(const std::function\u0026lt;void(const void*, size_t)\u0026gt;\u0026amp; cb);  Similar to log::set_write_cb(), but only writes a single log each time. It may be useful when users want to send logs by UDP.  #Printing logs\r#Basic usages\r#define DLOG if (FLG_min_log_level \u0026lt;= log::xx::debug) _DLOG_STREAM #define LOG if (FLG_min_log_level \u0026lt;= log::xx::info) _LOG_STREAM #define WLOG if (FLG_min_log_level \u0026lt;= log::xx::warning) _WLOG_STREAM #define ELOG if (FLG_min_log_level \u0026lt;= log::xx::error) _ELOG_STREAM #define FLOG _FLOG_STREAM \u0026lt;\u0026lt; \u0026#34;fatal error! \u0026#34;   The above 5 macros DLOG, LOG, WLOG, ELOG, FLOG are used to print 5 levels of logs respectively, they are thread safe.\n  These macros are actually references to fastream, so any type supported by fastream::operator\u0026lt;\u0026lt; can be printed.\n  These macros will automatically add a \u0026lsquo;\\n\u0026rsquo; at the end of each log, and users do not need to manually enter a newline character.\n  The first 4 types will only print the log when the FLG_min_log_level is not greater than the current log level. The user can set FLG_min_log_level to a larger value to disable low-level logs.\n  Print the fatal level log, which means that the program has a fatal error. The log library will print the function call stack information of the current thread and terminate the program.\n  Example\n  DLOG \u0026lt;\u0026lt; \u0026#34;this is DEBUG log \u0026#34;\u0026lt;\u0026lt; 23; LOG \u0026lt;\u0026lt; \u0026#34;this is INFO log \u0026#34;\u0026lt;\u0026lt; 23; WLOG \u0026lt;\u0026lt; \u0026#34;this is WARNING log \u0026#34;\u0026lt;\u0026lt; 23; ELOG \u0026lt;\u0026lt; \u0026#34;this is ERROR log \u0026#34;\u0026lt;\u0026lt; 23; FLOG \u0026lt;\u0026lt; \u0026#34;this is FATAL log \u0026#34;\u0026lt;\u0026lt; 23; #Condition Log\r#define DLOG_IF(cond) if (cond) DLOG #define LOG_IF(cond) if (cond) LOG #define WLOG_IF(cond) if (cond) WLOG #define ELOG_IF(cond) if (cond) ELOG #define FLOG_IF(cond) if (cond) FLOG   The above 5 macros accept a conditional parameter cond, and only print the log when cond is true.\n  The parameter cond can be any expression whose value is of type bool.\n  Since the condition is judged in the first place, even if the log of the corresponding level is disabled, these macros will ensure that the cond expression is executed.\n  Example\n  int s = socket(); DLOG_IF(s != -1) \u0026lt;\u0026lt; \u0026#34;create socket ok: \u0026#34;\u0026lt;\u0026lt; s;  LOG_IF(s != -1) \u0026lt;\u0026lt; \u0026#34;create socket ok: \u0026#34;\u0026lt;\u0026lt; s; WLOG_IF(s == -1) \u0026lt;\u0026lt; \u0026#34;create socket ko: \u0026#34;\u0026lt;\u0026lt; s; ELOG_IF(s == -1) \u0026lt;\u0026lt; \u0026#34;create socket ko: \u0026#34;\u0026lt;\u0026lt; s; FLOG_IF(s == -1) \u0026lt;\u0026lt; \u0026#34;create socket ko: \u0026#34;\u0026lt;\u0026lt; s; #Print log every N entries\r#define DLOG_EVERY_N(n) _LOG_EVERY_N(n, DLOG) #define LOG_EVERY_N(n) _LOG_EVERY_N(n, LOG) #define WLOG_EVERY_N(n) _LOG_EVERY_N(n, WLOG) #define ELOG_EVERY_N(n) _LOG_EVERY_N(n, ELOG)   The above macro prints the log once every n entries, internally counted by atomic operation, which is thread safe.\n  The parameter n must be an integer greater than 0, and generally should not exceed the maximum value of the int type.\n  When the parameter n is a power of 2, the log will be printed exactly once every n entries, otherwise there may be very few cases when it is not printed once every n entries.\n  The first log will always be printed.\n  The program will terminate as soon as the fatal log is printed, so FLOG_EVERY_N is not provided.\n  Example\n  // Print every 32 items (1,33,65...) DLOG_EVERY_N(32) \u0026lt;\u0026lt; \u0026#34;this is DEBUG log \u0026#34;\u0026lt;\u0026lt; 23; LOG_EVERY_N(32) \u0026lt;\u0026lt; \u0026#34;this is INFO log \u0026#34;\u0026lt;\u0026lt; 23; WLOG_EVERY_N(32) \u0026lt;\u0026lt; \u0026#34;this is WARNING log \u0026#34;\u0026lt;\u0026lt; 23; ELOG_EVERY_N(32) \u0026lt;\u0026lt; \u0026#34;this is ERROR log \u0026#34;\u0026lt;\u0026lt; 23; #Print the first N logs\r#define DLOG_FIRST_N(n) _LOG_FIRST_N(n, DLOG) #define LOG_FIRST_N(n) _LOG_FIRST_N(n, LOG) #define WLOG_FIRST_N(n) _LOG_FIRST_N(n, WLOG) #define ELOG_FIRST_N(n) _LOG_FIRST_N(n, ELOG)   The above macro prints the first n logs, internally counted by atomic operation, which is thread safe.\n  The parameter n is an integer not less than 0 (no log will be printed when it is equal to 0). Generally, it should not exceed the maximum value of the int type.\n  In general, do not use complex expressions for the parameter n.\n  The program will terminate as soon as the fatal log is printed, so FLOG_FIRST_N is not provided.\n  Example\n  // print the first 10 logs DLOG_FIRST_N(10) \u0026lt;\u0026lt; \u0026#34;this is DEBUG log \u0026#34;\u0026lt;\u0026lt; 23; LOG_FIRST_N(10) \u0026lt;\u0026lt; \u0026#34;this is INFO log \u0026#34;\u0026lt;\u0026lt; 23; WLOG_FIRST_N(10) \u0026lt;\u0026lt; \u0026#34;this is WARNING log \u0026#34;\u0026lt;\u0026lt; 23; ELOG_FIRST_N(10) \u0026lt;\u0026lt; \u0026#34;this is ERROR log \u0026#34;\u0026lt;\u0026lt; 23; #CHECK Assertion\r#define CHECK(cond) \\ if (!(cond)) _FLOG_STREAM \u0026lt;\u0026lt; \u0026#34;check failed: \u0026#34;#cond \u0026#34;!\u0026#34;  #define CHECK_NOTNULL(p) \\ if ((p) == 0) _FLOG_STREAM \u0026lt;\u0026lt; \u0026#34;check failed: \u0026#34;#p\u0026#34; mustn\u0026#39;t be NULL! \u0026#34;  #define CHECK_EQ(a, b) _CHECK_OP(a, b, ==) #define CHECK_NE(a, b) _CHECK_OP(a, b, !=) #define CHECK_GE(a, b) _CHECK_OP(a, b, \u0026gt;=) #define CHECK_LE(a, b) _CHECK_OP(a, b, \u0026lt;=) #define CHECK_GT(a, b) _CHECK_OP(a, b, \u0026gt;) #define CHECK_LT(a, b) _CHECK_OP(a, b, \u0026lt;)   The above macros can be regarded as an enhanced version of assert, and they will not be cleared in DEBUG mode.\n  These macros are similar to FLOG and can print fatal level logs.\n  CHECK asserts that the condition cond is true, and cond can be any expression with a value of type bool.\n  CHECK_NOTNULL asserts that the pointer is not NULL.\n  CHECK_EQ asserts a == b.\n  CHECK_NE asserts a != b.\n  CHECK_GE asserts a \u0026gt;= b.\n  CHECK_LE asserts a \u0026lt;= b.\n  CHECK_GT asserts a \u0026gt; b.\n  CHECK_LT asserts a \u0026lt; b.\n  It is generally recommended to use CHECK_XX(a, b) first, they provide more information than CHECK(cond), and will print out the values of parameters a and b.\n  Types not supported by fastream::operator\u0026lt;\u0026lt;, such as iterator type of STL containers, cannot use the CHECK_XX(a, b) macros.\n  When the assertion fails, the log library first calls log::close(), then prints the function call stack information of the current thread, and then exits the program.\n  Example\n  int s = socket(); CHECK(s != -1); CHECK(s != -1) \u0026lt;\u0026lt; \u0026#34;create socket failed\u0026#34;; CHECK_NE(s, -1) \u0026lt;\u0026lt; \u0026#34;create socket failed\u0026#34;; // s != -1 CHECK_GE(s, 0) \u0026lt;\u0026lt; \u0026#34;create socket failed\u0026#34;; // s \u0026gt;= 0 CHECK_GT(s, -1) \u0026lt;\u0026lt; \u0026#34;create socket failed\u0026#34;; // s \u0026gt; -1  std::map\u0026lt;int, int\u0026gt; m; auto it = m.find(3); CHECK(it != m.end()); // Cannot use CHECK_NE(it, m.end()), the compiler will report an error #Stack trace\rco/log will print the function call stack when CHECK assertion failed, or an abnormal signal like SIGSEGV was caught. See details below:\n(https://asciinema.org/a/435894)\nOn linux and macosx, libbacktrace is required, make sure you have installed it on your system. On linux, libbacktrace may have been installed within a newer version of gcc. You may find it in a directory like /usr/lib/gcc/x86_64-linux-gnu/9. Otherwise, you can install it by yourself as follow:\ngit clone https://github.com/ianlancetaylor/libbacktrace.git cd libbacktrace-master ./configure make -j8 sudo make install #Configuration\r#log_dir\rDEF_string(log_dir, \u0026#34;logs\u0026#34;, \u0026#34;#0 log dir, will be created if not exists\u0026#34;);  Specify the log directory. The default is the logs directory under the current directory. If it does not exist, it will be created automatically. log_dir can be an absolute path or a relative path, and the path separator can be either \u0026lsquo;/\u0026rsquo; or \u0026lsquo;'. It is generally recommended to use \u0026lsquo;/\u0026rsquo;. When the program starts, make sure that the current user has sufficient permissions, otherwise the creation of the log directory may fail.  #log_file_name\rDEF_string(log_file_name, \u0026#34;\u0026#34;, \u0026#34;#0 name of log file, using exename if empty\u0026#34;);  Specify the log file name (without path), the default is empty, use the program name (.exe at the end will be removed), for example, the log file name corresponding to program xx or xx.exe is xx .log. If the log file name does not end with .log, co/log automatically adds .log to the end of it.  #min_log_level\rDEF_int32(min_log_level, 0, \u0026#34;#0 write logs at or above this level, 0-4 (debug|info|warning|error|fatal)\u0026#34;);  Specify the minimum level of logs to be printed, which can be used to disable low-level logs, the default is 0, and all levels of logs are printed.  #max_log_size\rDEF_int32(max_log_size, 4096, \u0026#34;#0 max size of a single log\u0026#34;);  Specify the maximum size of a single log, the default is 4k. A log will be truncated if its size is larger than this value. This value cannot exceed half of max_log_buffer_size.  #max_log_file_size\rDEF_int64(max_log_file_size, 256 \u0026lt;\u0026lt; 20, \u0026#34;#0 max size of log file, default: 256MB\u0026#34;);  Specify the maximum size of a log file. The default is 256M. If this size is exceeded, a new log file will be generated, and the old log file will be renamed.  #max_log_file_num\rDEF_uint32(max_log_file_num, 8, \u0026#34;#0 max number of log files\u0026#34;);  Specify the maximum number of log files. The default is 8. If this value is exceeded, old log files will be deleted.  #max_log_buffer_size\rDEF_uint32(max_log_buffer_size, 32 \u0026lt;\u0026lt; 20, \u0026#34;#0 max size of log buffer, default: 32MB\u0026#34;);  Specify the maximum size of the log cache. The default is 32M. If this value is exceeded, about half of the logs will be lost.  #log_flush_ms\rDEF_uint32(log_flush_ms, 128, \u0026#34;#0 flush the log buffer every n ms\u0026#34;);  The time interval for the background thread to flush the log cache to the file, in milliseconds.  #cout\rDEF_bool(cout, false, \u0026#34;#0 also logging to terminal\u0026#34;);  Terminal log switch, the default is false. If true, logs will also be printed to the terminal.  #also_log_to_local\rDEF_bool(also_log_to_local, false, \u0026#34;#0 if true, also log to local file when write-cb is set\u0026#34;);  If the value is true, also write logs to a local file when a write_cb has been set.  #Log file\r#Log Organization\rco/log will record all levels of logs in the same file. By default, the program name is used as the log file name. For example, the log file of process xx is xx.log. When the log file reaches the maximum size (FLG_max_log_file_size), co/log will rename the log file and generate a new file. The log directory may contain the following files:\nxx.log xx_1.log xx_2.log xx_3.log xx.log is always the latest log file. For other files, the smaller the number in the file name, the newer the log. When the number in the file name reaches the maximum number of files (FLG_max_log_file_num), co/log will delete the file.\nfatal level logs will be additionally recorded in the xx.fatal file, co/log will not rename or delete the fatal log file.\n#Log format\rI0514 11:15:30.123 1045 test/xx.cc:11] hello world D0514 11:15:30.123 1045 test/xx.cc:12] hello world W0514 11:15:30.123 1045 test/xx.cc:13] hello world E0514 11:15:30.123 1045 test/xx.cc:14] hello world F0514 11:15:30.123 1045 test/xx.cc:15] hello world  In the above example, each line corresponds to one log. The first letter of each log is the log level, I means info, D means debug, W means warning, E means error, and F means fatal. After the level is the time, from month to milliseconds. The year is not printed. The time of the log is not the time when it is generated, but the time when it is written to the cache, as we must ensure that the logs in the log file are strictly sorted by time. After the time is the thread id, 1045 above is the thread id. The thread id is followed by the file and line number of the log code. After the line number is ] , that is, a space after ]. following the ] ，is the log content by the user.  #View logs\rOn linux or mac, grep, tail and other commands can be used to view the logs.\ngrep ^E xx.log tail -F xx.log tail -F xx.log | grep ^E  The first line uses grep to filter out the error logs in the file, ^E means starts with the letter E. The second line uses the tail -F command to dynamically track the log file, here we should use the uppercase F, because xx.log may be renamed, and then generate a new xx.log file, -F make sure to follow the latest file by the name. In line 3, use tail -F in conjunction with grep to dynamically track the error logs in the log file.  #Build and run the co/log test program\rxmake -b log # build log or log.exe xmake r log # run log or log.exe xmake r log -cout # also log to terminal xmake r log -min_log_level=1 # 0-4: debug,info,warning,error,fatal xmake r log -perf # performance test  Run xmake -b log in the co root directory to compile test/log.cc, and a binary program named log or log.exe will be generated.  "},{"id":11,"href":"/en/co/unitest/","title":"Unitest","section":"Documents for CO","content":"include: co/unitest.h.\n#Basic concepts\rco/unitest is a unit testing framework, similar to google gtest, but easier to use.\n#Test Units and Test Cases\rA test program can be divided into multiple test units according to functions or modules, and there can be multiple test cases under each test unit. For example, a test unit can be defined for a class (or module) in C++, and a test case can be defined for each method in the class (or module).\nIn co/unitest, when a test unit is defined, a class is generated, and there is a run() method in the class, and code of all test cases are in the run() method. co/unitest almost hides all the details. Users can\u0026rsquo;t see the class, or even the run() method, so they can concentrate on writing test code:\nDEF_test(test_name) {  DEF_case(a) {  // write test code here  }   DEF_case(b) {  // write test code here  } } The above DEF_test actually implements the run() method in the class, while DEF_case defines a test case. A test case is actually a code block in the run() method, not even a function.\n#DEF_test\r#define DEF_test(_name_) \\ DEF_bool(_name_, false, \u0026#34;enable this test if true.\u0026#34;); \\ ... \\ void _UTest_##_name_::run()  The DEF_test macro is used to define a test unit, and the parameter _name_ is the name of the test unit. The first line of the macro defines a bool type flag variable, which is the switch of the test unit. For example, DEF_test(os) defines a test unit os, and we can use -os in the command line to enable test cases in this unit. The codes omitted in the middle of the macro actually defines a class, and the last line defines the method run() in the class, which requires the user to complete the function body.  #DEF_case\r#define DEF_case(name) _current_case.reset(new unitest::Case(#name));  The DEF_case macro is used to define a test case in the test unit. The parameter name is the name of the test case. It must be used inside the run() method defined by DEF_test. The name of a test unit must be albe to use as part of the class name or variable name. The test case name does not have this restriction. For example, DEF_case(sched.Copool) is also reasonable. The code after DEF_case is all test code of this test case until the next DEF_case appears. The code of the test case is generally enclosed by a pair of curly braces to isolate it from other test cases. DEF_test may not contain any DEF_case. In this case, co/unitest will create a default test case.  #EXPECT assertion\r#define EXPECT(x) ... #define EXPECT_EQ(x, y) EXPECT_OP(x, y, ==, \u0026#34;EQ\u0026#34;) #define EXPECT_NE(x, y) EXPECT_OP(x, y, !=, \u0026#34;NE\u0026#34;) #define EXPECT_GE(x, y) EXPECT_OP(x, y, \u0026gt;=, \u0026#34;GE\u0026#34;) #define EXPECT_LE(x, y) EXPECT_OP(x, y, \u0026lt;=, \u0026#34;LE\u0026#34;) #define EXPECT_GT(x, y) EXPECT_OP(x, y, \u0026gt;, \u0026#34;GT\u0026#34;) #define EXPECT_LT(x, y) EXPECT_OP(x, y, \u0026lt;, \u0026#34;LT\u0026#34;)  EXPECT asserts that x is true, and x can be any expression with a value of type bool. EXPECT_EQ asserts x == y. EXPECT_NE asserts x != y. EXPECT_GE asserts that x \u0026gt;= y. EXPECT_LE asserts that x \u0026lt;= y. EXPECT_GT asserts that x \u0026gt; y. EXPECT_LT asserts that x \u0026lt; y. When defining a test case with DEF_case, you can use these macro assertions. If an assertion fails, it means that the test case fails. The terminal will print related error messages in red color.  #Write test code\r#Test code example\r// os.cc #include \u0026#34;co/unitest.h\u0026#34;#include \u0026#34;co/os.h\u0026#34; namespace test {  DEF_test(os) {  DEF_case(homedir) {  EXPECT_NE(os::homedir(), \u0026#34;\u0026#34;);  }   DEF_case(pid) {  EXPECT_GE(os::pid(), 0);  }   DEF_case(cpunum) {  EXPECT_GT(os::cpunum(), 0);  } }  } // namespace test  The above code defines a test unit named os, and os has 3 test cases. When running the test program, you can use -os in the command line to enable this unit test. The code of different test units are generally put in different .cc source files. The user can put test code in a namespace, if necessary.  #Default test case\rDEF_test(os) {  EXPECT_NE(os::homedir(), \u0026#34;\u0026#34;);  EXPECT_GE(os::pid(), 0);  EXPECT_GT(os::cpunum(), 0); }  The above code does not contain any DEF_case, co/unitest will create a default test case named \u0026ldquo;default\u0026rdquo;. For more complex test codes, it is generally not recommended to use the default test cases. It is better to divide them into different cases so that the code looks clearer.  #main() function\r#include \u0026#34;co/unitest.h\u0026#34; int main(int argc, char** argv) {  flag::init(argc, argv);  unitest::run_all_tests();  return 0; }  Call the run_all_tests() method provided by co/unitest in the main function to start running the test code. Before calling run_all_tests(), the flag::init() method must be called to parse the command line parameters.  #Build and run the test program\r#Build the unitest code\rxmake -b unitest  Execute the above command in the co root directory to compile the unit test code in the co/unitest directory and generate the unitest binary program .  #Run all test cases\rDEF_bool(a, false, \u0026#34;.Run all tests if true\u0026#34;);  FLG_a is a flag variable defined inside co/unitest. When the value is true, all test cases are enabled. You can use -a on the command line to specify to run all test cases.  # Run all test cases xmake r unitest -a #Run test cases in specified test units\r# Run only test cases in the os test unit xmake r unitest -os  # Run test cases in the os or json test units xmake r unitest -os -json  By default, all test units are disabled, you need to enable the test code with the corresponding switch.  #Test result example\r All tests passed   Test case failed  "},{"id":12,"href":"/en/co/json/","title":"JSON","section":"Documents for CO","content":"include: co/json.h.\nco/json is a JSON library similar to rapidjson. Compared with rapidjson, it has certain performance advantages and is easier to use.\nIn the latest version, a JSON is built into a contiguous memory, which greatly reduces memory allocations. The parsing speed has also been significantly improved, which can be twice faster as rapidjson. Since a JSON object is a contiguous piece of memory, it is easy to copy, so reference counting used in earlier versions is removed.\n#Basic concepts\r#JSON data format\rJSON is a simple data format that supports two data structures:\n A collection consisting of a series of key/value pairs. This type of structure is called object, which corresponds to struct, map, etc, in programming languages. A list composed of a series of value, this kind of structure is called array, which corresponds to vector, list, etc, in programming languages.  In the above, the key is a string, and the value is generally called JSON value, which can be any of object, array, number, string, bool(false, true), or null. number is an integer or floating-point number, and most implementations will distinguish integers from floating-point numbers.\nobject is enclosed by a pair of braces, array is enclosed by a pair of square brackets, they look like this:\n{\u0026#34;a\u0026#34;:1, \u0026#34;b\u0026#34;:false, \u0026#34;s\u0026#34;:\u0026#34;xxx\u0026#34;} [1, 3.14, true, \u0026#34;xxx\u0026#34;] By definition, object and array can be nested, which can represent complex data structures such as trees.\n#json::Json\rco/json uses the json::Json class to represent JSON. For convenience, the following typedef definition is also given:\ntypedef json::Json Json; The Json class has only one data member, a pointer, which points to a contiguous memory. In practical applications, Json is generally of object or array type.\n#json::Value\rco/json uses the json::Value class to represent JSON value, which can be any of object, array, string, int, double, bool, null.\nThe structure of json::Value is as follows:\nclass Value {  Json* _root;  uint32 _index; }; It contains a pointer of the Json class, and an index, which indicates its position in the Json memory block. Users cannot create json::Value objects directly, they can only be created by methods in the Json class.\njson::Value supports almost all operations in the Json class. Therefore, the following documents about the Json class generally also apply to the json::Value class.\n#json::Json (Json)\r#Json::Json\rJson(); Json(Json\u0026amp;\u0026amp; r); Json(const Json\u0026amp; r);  The first version is the default constructor, which constructs a null object. The second version is the move constructor. The content of the parameter r is transferred to the constructed Json object, and r itself is invalid. The third version is the copy constructor, which constructs a Json object through memory copy.  #json::array\rJson array();  This function is in namespace json, it returns an empty array.  #json::object\rJson object();  This function is in namespace json, it returns an empty object.  #Json::operator=\rJson\u0026amp; operator=(const Json\u0026amp; r); Json\u0026amp; operator=(Json\u0026amp;\u0026amp; r) noexcept;  The first version performs a memory copy and overwrites the original content with the content of r. The second version directly transfers the content of r, and r itself becomes invalid.  #———————————\r#Json::add_member\rvoid add_member(const char* key, bool x); void add_member(const char* key, int64 x); void add_member(const char* key, int x); void add_member(const char* key, uint32 x); void add_member(const char* key, uint64 x); void add_member(const char* key, double x); void add_member(const char* key, const char* x, size_t n); void add_member(const char* key, const char* x); void add_member(const char* key, const std::string\u0026amp; x); void add_member(const char* key, const fastring\u0026amp; x);   Add key-value pairs to Json of object type (null automatically becomes object after calling this method).\n  The parameter key is a C string ending in '\\0', and the parameter x is the value.\n  The first version adds a value of bool type.\n  Versions 2-5 add a value of integer type.\n  The sixth version adds a value of double type.\n  Versions 7-10 add a value of string type.\n  NOTE: for performance reasons, it is required that the key cannot contain double quotes, and it is best not to contain any escape characters. I have never seen anyone use it in this way. If so, please let me know and I will consider supporting it.\n  Example\n  Json r; r.add_member(\u0026#34;a\u0026#34;, 1); // r -\u0026gt; {\u0026#34;a\u0026#34;:1} r.add_member(\u0026#34;d\u0026#34;, 3.3); // r -\u0026gt; {\u0026#34;a\u0026#34;:1, \u0026#34;d\u0026#34;:3.3} r.add_member(\u0026#34;s\u0026#34;, \u0026#34;xx\u0026#34;); // r -\u0026gt; {\u0026#34;a\u0026#34;:1, \u0026#34;d\u0026#34;:3.3, \u0026#34;s\u0026#34;:\u0026#34;xx\u0026#34;} #Json::add_null\rvoid add_null(const char* key);  Add null to an object. Example  Json r; r.add_null(\u0026#34;x\u0026#34;); // r -\u0026gt; {\u0026#34;x\u0026#34;: null} #Json::add_array\rValue add_array(const char* key, uint32 cap=0);   Add an empty array to an object.\n  The parameter cap specifies the initial capacity of the added array, and the default is 0. If you know in advance that the size of the array is n, you can directly set cap to n, which can reduce unnecessary memory reallocation and consumption.\n  This method returns a json::Value representing the array added. The user can continue to add elements to the array through the return value.\n  Example\n  Json r; auto a = r.add_array(\u0026#34;xxx\u0026#34;, 3); // r -\u0026gt; {\u0026#34;xxx\u0026#34;: []} a.push_back(1, 2, 3); // r -\u0026gt; {\u0026#34;xxx\u0026#34;: [1,2,3]} #Json::add_object\rValue add_object(const char* key, uint32 cap=0);   Add an empty object to an object.\n  The parameter cap specifies the initial capacity of the added object, and the default is 0. If you know the size of the object as n in advance, you can directly set the cap to n, which can reduce unnecessary memory reallocation and consumption.\n  This method returns a json::Value object representing the object added. The user can continue to add elements to the object through the return value.\n  Example\n  Json r; auto o = r.add_object(\u0026#34;xxx\u0026#34;, 3); // r -\u0026gt; {\u0026#34;xxx\u0026#34;: {}} o.add_member(\u0026#34;a\u0026#34;, 1); // r -\u0026gt; {\u0026#34;xxx\u0026#34;: {\u0026#34;a\u0026#34;:1}} o.add_member(\u0026#34;b\u0026#34;, 2); // r -\u0026gt; {\u0026#34;xxx\u0026#34;: {\u0026#34;a\u0026#34;:1, \u0026#34;b\u0026#34;:2}} o.add_member(\u0026#34;c\u0026#34;, 3); // r -\u0026gt; {\u0026#34;xxx\u0026#34;: {\u0026#34;a\u0026#34;:1, \u0026#34;b\u0026#34;:2, \u0026#34;c\u0026#34;:3}} #Json::push_back\rvoid push_back(bool x); void push_back(int64 x); void push_back(int x); void push_back(uint32 x); void push_back(uint64 x); void push_back(double x); void push_back(const char* x, size_t n); void push_back(const char* x); void push_back(const std::string\u0026amp; x); void push_back(const fastring\u0026amp; x); template \u0026lt;typename X, typename ...V\u0026gt; void push_back(X x, V... v);   Add elements to an array (null automatically becomes an array after calling this method).\n  The first version adds a value of bool type.\n  Versions 2-5 add a value of integer type.\n  The sixth version adds a value of double type.\n  Versions 7-10 add a value of string type.\n  The 11th version accepts any number of parameters, and the parameters must be of the type in version 1-10.\n  Example\n  Json r; r.push_back(1); // r -\u0026gt; [1] r.push_back(3.3); // r -\u0026gt; [1, 3.3] r.push_back(\u0026#34;xx\u0026#34;); // r -\u0026gt; [1, 3.3, \u0026#34;xx\u0026#34;]  Json s; s.push_back(1, 3.3, \u0026#34;xx\u0026#34;); // s -\u0026gt; [1, 3.3, \u0026#34;xx\u0026#34;] #Json::push_null\rvoid push_null();   Add null to an array.\n  Example\n  Json r; r.push_null(); // r -\u0026gt; [null] #Json::push_array\rValue push_array(uint32 cap=0);  Add an empty array to an array. The parameter cap specifies the initial capacity of the added array, and the default is 0. If you know in advance that the size of the array is n, you can directly set cap to n, which can reduce unnecessary memory reallocation and consumption. This method returns a json::Value object representing the array added. The user can continue to add elements to the array through the return value. Example  Json r; auto a = r.push_array(3); // r -\u0026gt; [[]] a.push_back(1, 2, 3.3); // r -\u0026gt; [[1, 2, 3.3]] #Json::push_object\rValue push_object(uint32 cap=0);   Add an empty object to an array.\n  The parameter cap specifies the initial capacity of the added object, and the default is 0. If you know the size of the object as n in advance, you can directly set the cap to n, which can reduce unnecessary memory reallocation and consumption.\n  This method returns a json::Value object representing the object added. The user can continue to add elements to the object through the return value.\n  Example\n  Json r; auto o = r.push_object(3); // r -\u0026gt; [{}] o.add_member(\u0026#34;a\u0026#34;, 1); // r -\u0026gt; [{\u0026#34;a\u0026#34;:1}] o.add_member(\u0026#34;b\u0026#34;, 2); // r -\u0026gt; [{\u0026#34;a\u0026#34;:1, \u0026#34;b\u0026#34;:2}] o.add_member(\u0026#34;c\u0026#34;, 3); // r -\u0026gt; [{\u0026#34;a\u0026#34;:1, \u0026#34;b\u0026#34;:2, \u0026#34;c\u0026#34;:3}] #Json::str\rfastream\u0026amp; str(fastream\u0026amp; fs) const; fastring str(uint32 cap=256) const;  Convert Json to a string. The first version writes the JSON string into a fastream, and the return value is the same as the parameter fs. The second version directly returns a JSON string. The parameter cap is the initial capacity of the string, and the default is 256. Setting it to an appropriate value can reduce memory reallocation.  #Json::pretty\rfastream\u0026amp; pretty(fastream\u0026amp; fs) const; fastring pretty(uint32 cap=256) const;  Like the str(), but convert Json to a more beautiful JSON string.  #Json::dbg\rfastream\u0026amp; dbg(fastream\u0026amp; fs) const; fastring dbg(uint32 cap=256) const;  Convert Json to a debug string, like Json::str(), but will truncate string type to the first 32 bytes if its length exceeds 512 bytes. This method is generally used to print logs. In some application scenarios, the Json object may contain a long string, such as the base64 encoding of a picture file. At this time, use Json::dbg() instead of Json::str() to avoid printing too many significant logs.  #Json::parse_from\rbool parse_from(const char* s, size_t n); bool parse_from(const char* s); bool parse_from(const fastring\u0026amp; s); bool parse_from(const std::string\u0026amp; s);  Parse Json from a JSON string. In the first version, s is not required to end with '\\0'. When the parsing is successful, it returns true, otherwise it returns false. When the parsing fails, the internal state of Json is uncertain. If the user does not check the return value, and use the Json object directly, it may cause undefined behavior. It is recommended to use json::parse() instead of this method, which always returns a null when parsing failed.  #json::parse\rJson parse(const char* s, size_t n); Json parse(const char* s); Json parse(const fastring\u0026amp; s); Json parse(const std::string\u0026amp; s);  Parse Json from a JSON string. This function is not a method in the Json class, but a function defined in namespace json. This function returns a Json object, when the parsing failed, it returns null.  #Code example\rJson r; auto a = r.add_array(\u0026#34;a\u0026#34;); a.push_back(1, 2, 3);  fastring s = r.str(); // s -\u0026gt; \u0026#34;{\\\u0026#34;a\\\u0026#34;:[1,2,3]}\u0026#34; fastring p = r.pretty(); LOG \u0026lt;\u0026lt; r.dbg(); // print json debug string LOG \u0026lt;\u0026lt; r; // the same as above, but may be more efficient  Json x; x.parse_from(s); x.parse_from(p);  s = \u0026#34;{\\\u0026#34;a\\\u0026#34;:[1,false,3.14]}\u0026#34;; Json v = json::parse(s); // v -\u0026gt; {\u0026#34;a\u0026#34;:[1,false,3.14]} #———————————\r#Json::is_null\rbool is_null() const;  Determine whether the Json is null.  #Json::is_bool\rbool is_bool() const;  Determine whether the Json is of type bool.  #Json::is_int\rbool is_int() const;  Determine whether the Json is an integer type.  #Json::is_double\rbool is_double() const;  Determine whether the Json is of type double.  #Json::is_string\rbool is_string() const;  Determine whether the Json is a string type.  #Json::is_array\rbool is_array() const;  Determine whether the Json is an array type.  #Json::is_object\rbool is_object() const;  Determine whether the Json is an object type.  #———————————\r#Json::get_bool\rbool get_bool() const;  Get value of bool type. Return false if the Json calling this method is not bool type.  #Json::get_int\rint get_int() const; int32 get_int32() const; int64 get_int64() const; uint32 get_uint32() const; uint64 get_uint64() const;  Get value of integer type. Return 0 if the Json calling these methods is not integer type.  #Json::get_double\rdouble get_double() const;  Get value of double type. Return 0.0 if the Json object calling this method is not double type.  #Json::get_string\rconst char* get_string() const;  Get value of string type. Return empty string if the Json calling this method is not string type. This method returns the C string ending with '\\0', and the user can also call the string_size() method to get the length of the string.  #Code example\rJson r; r.add_member(\u0026#34;a\u0026#34;, 1); r.add_member(\u0026#34;d\u0026#34;, 3.3); r.add_member(\u0026#34;s\u0026#34;, \u0026#34;xx\u0026#34;);  r[\u0026#34;a\u0026#34;].get_int(); // 1 r[\u0026#34;d\u0026#34;].get_double(); // 3.3 r[\u0026#34;s\u0026#34;].get_string(); // \u0026#34;xx\u0026#34; #———————————\r#Json::set_null\rvoid set_null();  Set the Json to null.  #Json::set_array\rvoid set_array();  Set the Json to an empty array.  #Json::set_object\rvoid set_object();  Set the Json to an empty object.  #Code example\rJson r; r.set_array(); // r -\u0026gt; [] r.push_back(1); // r -\u0026gt; [1] r.set_object(); // r -\u0026gt; {} r.set_null(); // r -\u0026gt; null #———————————\r#Json::operator[]\rValue operator[](int i) const; Value operator[](uint32 i) const; Value operator[](const char* key) const   Overload operator[], get the elements in the Json, and return a json::Value.\n  The first two versions are applicable to array types, the parameter i is the offset of the element in the array, and i must be within the range of the array.\n  The third version is applicable to object types. If the element corresponding to the key does not exist, null is returned.\n  Example\n  Json r; r.add_member(\u0026#34;x\u0026#34;, 1); auto a = r.add_array(\u0026#34;a\u0026#34;); a.push_back(1, 2, 3); // r -\u0026gt; {\u0026#34;x\u0026#34;:1, \u0026#34;a\u0026#34;:[1,2,3]}  auto x = r[\u0026#34;x\u0026#34;]; x.get_int(); // 1  a = r[\u0026#34;a\u0026#34;]; a.array_size(); // 3 a[0].get_int(); // 1 a[1].get_int(); // 2 #Json::has_member\rbool has_member(const char* key) const;   Determine whether there is an element corresponding to key in Json.\n  The Json calling this method must be object or null.\n  Example\n  Json r; r.add_member(\u0026#34;a\u0026#34;, 1); r.has_member(\u0026#34;a\u0026#34;); // true r.has_member(\u0026#34;x\u0026#34;); // false #Json::size\ruint32 size() const;   If Json is object or array, this method returns the number of elements.\n  If Json is a string type, this method returns the length of the string.\n  For all other types, this method returns 0.\n  Example\n  Json r; r.add_member(\u0026#34;x\u0026#34;, 1); auto a = r.add_array(\u0026#34;a\u0026#34;); a.push_back(1, 2, 3); // r -\u0026gt; {\u0026#34;x\u0026#34;:1, \u0026#34;a\u0026#34;:[1,2,3]}  r.size(); // 2 r[\u0026#34;x\u0026#34;].size(); // 0 r[\u0026#34;a\u0026#34;].size(); // 3 #Json::string_size\ruint32 string_size() const;  Returns the length of the string type. Return 0 if the Json calling this method is not string type.  #Json::array_size\ruint32 array_size() const;  Returns the number of elements of array type. Return 0 if the Json calling this method is not array type.  #Json::object_size\ruint32 object_size() const;  Returns the number of elements of object type. Return 0 if the Json calling this method is not object type.  #———————————\r#Json::begin\riterator begin() const;  Returns the beginning iterator. The Json calling this method must be array, object or null. When the Json is empty, the return value is equal to Json::end().  #Json::end\rconst iterator::End\u0026amp; end() const;  Returns a fake end iterator. The return value is actually not an iterator object, but a iterator can be compared with it. If iterator is equal to Json::end(), it means that there is no more element.  #Json::iterator\r#iterator::operator==\rbool operator==(const End\u0026amp;) const;  Determine whether a iterator is equal to End, End is the fake end iterator.  #iterator::operator!=\rbool operator!=(const End\u0026amp;) const;  Determine if a iterator is not equal to End, End is the fake end iterator.  #iterator::operator++\riterator\u0026amp; operator++();  The prefix operator++.  #iterator::operator*\rValue operator*() const;  Overload operator*, this method only applies to iterator of array type. When Json is an array, the iterator points to the elements in the array. This method returns a json::Value that represents the element pointed to by the iterator.  #iterator::key\rconst char* key();  This method only applies to iterator of object type. When Json is an object, the iterator points to the key-value pair in the object, and this method returns the key.  #iterator::value\rValue value();  This method only applies to iterator of object type. When Json is an object, the iterator points to the key-value pair in the object, and this method returns the value.  #Traversing the Json\rco/json supports traversing a Json of type array or object by iterator:\n// {\u0026#34;i\u0026#34;:7, \u0026#34;s\u0026#34;:\u0026#34;xx\u0026#34;, \u0026#34;a\u0026#34;:[123, true, \u0026#34;nice\u0026#34;]} Json r; r.add_member(\u0026#34;i\u0026#34;, 7); r.add_member(\u0026#34;s\u0026#34;, \u0026#34;xx\u0026#34;); auto a = r.add_array(\u0026#34;a\u0026#34;); a.push_back(123, true, \u0026#34;nice\u0026#34;);  // object for (auto it = r.begin(); it != r.end(); ++it) {  LOG \u0026lt;\u0026lt; it.key() \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; it.value(); }  // array a = r[\u0026#34;a\u0026#34;]; for (auto it = a.begin(); it != a.end(); ++it) {  LOG \u0026lt;\u0026lt; (*it); } #json::Value\rThe constructor of json::Value is private, and users cannot create json::Value objects directly.\njson::Value is generally used as an intermediate temporary object, it supports all methods in the Json class except parse_from() and safe_clear(), and its usage is exactly the same, so I won\u0026rsquo;t repeat it here. In addition, it also supports some assignment operations that the Json does not support.\n#json::Value::operator=\rvoid operator=(bool x); void operator=(int64 x); void operator=(int32 x); void operator=(uint32 x); void operator=(uint64 x); void operator=(double x); void operator=(const char* x); void operator=(const fastring\u0026amp; x); void operator=(const std::string\u0026amp; x);   Assignment, set value of json::Value to the value specified by the parameter x, and the type of json::Value will also become the corresponding type.\n  Example\n  Json r; r.add_member(\u0026#34;x\u0026#34;, 1);  auto a = r[\u0026#34;x\u0026#34;]; a = 3; // r -\u0026gt; {\u0026#34;x\u0026#34;: 3} a = false; // r -\u0026gt; {\u0026#34;x\u0026#34;: false} a = \u0026#34;nice\u0026#34;; // r -\u0026gt; {\u0026#34;x\u0026#34;: \u0026#34;nice\u0026#34;} r[\u0026#34;x\u0026#34;] = 3.3; // r -\u0026gt; {\u0026#34;x\u0026#34;: 3.3} #Performance optimization suggestions\rSome users may add members in the following way:\nJson r; r[\u0026#34;a\u0026#34;] = 1; r[\u0026#34;s\u0026#34;] = \u0026#34;hello world\u0026#34;; Although the above code works, the efficiency is not very high. The operator[] will first look up the key which may be slow. It is generally recommended to use add_member() instead:\nJson r; r.add_member(\u0026#34;a\u0026#34;, 1); r.add_member(\u0026#34;s\u0026#34;, \u0026#34;hello world\u0026#34;); The object type is actually stored in the form of an array, and operator[] will compare with the keys in the array one by one. In occasions where performance is particularly important, it is recommended to cache the result of operator[] instead of calling operator[] multiple times for the same key.\nJson r; r.add_member(\u0026#34;a\u0026#34;, 1);  auto a = r[\u0026#34;a\u0026#34;]; if (a.is_int()) LOG \u0026lt;\u0026lt; a.get_int(); "},{"id":13,"href":"/en/co/time/","title":"Time","section":"Documents for CO","content":"include: co/time.h.\n#epoch time\rThe EPOCH is a specific time 1970-01-01 00:00:00 UTC, and the epoch time is the time since the EPOCH.\n#epoch::ms\rint64 ms();  Return milliseconds since EPOCH.  #epoch::us\rint64 us();  Return microseconds since EPOCH.  #monotonic time\rMonotonic time is a monotonic increasing time, it is implemented as the time since last reboot of system on most platforms . It is generally used for timing and is more stable than system time.\n#now::ms\rint64 ms();  Returns a monotonically increasing timestamp in milliseconds. On mac platform, if the system does not support CLOCK_MONOTONIC, use epoch::ms().  #now::us\rint64 us();   Returns a monotonically increasing timestamp in microseconds.\n  On mac platform, if the system does not support CLOCK_MONOTONIC, use epoch::us().\n  Example\n  int64 beg = now::us(); int64 end = now::us(); LOG \u0026lt;\u0026lt; \u0026#34;time used: \u0026#34;\u0026lt;\u0026lt; (end-beg) \u0026lt;\u0026lt;\u0026#34; us\u0026#34;; #Time string (now::str)\r// fm: time output format fastring str(const char* fm=\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;);   This function returns the string form of the current system time in the specified format. It is implemented based on strftime.\n  Example\n  fastring s = now::str(); // \u0026#34;2021-07-07 17:07:07\u0026#34; fastring s = now::str(\u0026#34;%Y\u0026#34;); // \u0026#34;2021\u0026#34; #sleep\r#sleep::ms\rvoid ms(uint32 n);  Sleep for n milliseconds.  #sleep::sec\rvoid sec(uint32 n);   Sleep for n seconds.\n  Example\n  sleep::ms(10); // sleep for 10 milliseconds sleep::sec(1); // sleep for 1 second #Timer (Timer)\rThe Timer class is a simple timer based on monotonic time.\n#Timer::Timer\rTimer();  Constructor, set the start time of the timer, and start timing when the object is created.  #Timer::ms\rint64 ms() const;  Return milliseconds since start of the timing.  #Timer::us\rint64 us() const;  Return microseconds since start of the timing.  #Timer::restart\rvoid restart();   Restart the timer.\n  Example\n  Timer t; sleep::ms(10); int64 us = t.us();  t.restart(); sleep::ms(20); int64 ms = t.ms(); "},{"id":14,"href":"/en/co/thread/","title":"Thread","section":"Documents for CO","content":"include: co/thread.h.\n#Thread\rThe Thread class is an encapsulation of the thread. When a Thread object is created, the thread will be started. Once the thread is started, it will run until the thread function exits. The Thread class does not provide a method for forcing terminating the thread (something like pthread_cancel). This type of method is usually unsafe and may cause damage to user data.\n#Thread::Thread\rexplicit Thread(co::Closure* cb);  template\u0026lt;typename F\u0026gt; explicit Thread(F\u0026amp;\u0026amp; f);  template\u0026lt;typename F, typename P\u0026gt; Thread(F\u0026amp;\u0026amp; f, P\u0026amp;\u0026amp; p);  template\u0026lt;typename F, typename T, typename P\u0026gt; Thread(F\u0026amp;\u0026amp; f, T* t, P\u0026amp;\u0026amp; p);   Constructor, the thread will start after the Thread object is created.\n  In the first version, the parameter cb is a pointer of Closure type. Generally, users are not recommended to use this version directly.\n  For the 2-4th version, a Closure object is constructed according to the passed in parameters, and then the first version is called.\n  In the second version, the parameter f is any runnable object, as long as we can call f() or (*f)().\n  In the third version, the parameter f is any runnable object, as long as we can call f(p), (*f)(p) or (p-\u0026gt;*f)().\n  In the fourth version, the parameter f is a method with one parameter in class T, the parameter t is a pointer of type T, and p is the parameter of f.\n  Example\n  Thread x([](){}); // lambda Thread x(f); // void f(); Thread x(f, p); // void f(void*); void* p; Thread x(f, 7); // void f(int v); Thread x(\u0026amp;T::f, \u0026amp;t); // void T::f(); T t; Thread x(\u0026amp;T::f, \u0026amp;t, 7); // void T::f(int v); T t; Thread x(std::bind(\u0026amp;T::f, \u0026amp;t, 7)); // void T::f(int v); T t; #Thread::~Thread\rThread::~Thread();  Destructor, call the join() method, wait for the thread to exit, and release system resources.  #Thread::detach\rvoid detach();   Let the thread run independently of the Thread object. Once this method is called, the Thread object is useless. When the thread function exits, the system resources are automatically released.\n  Example\n  void f(); Thread(f).detach(); // run f() in a thread #Thread::join\rvoid join();  Calling this method will block until the thread function exits, and then release system resources. If the detach() method has been called before, nothing will happen when calling this method.  #co::thread_id\ruint32 thread_id();  This function returns the id of the current thread. In the internal implementation, TLS is used to save the thread id, and each thread only needs one system call.  #current_thread_id\ruint32 current_thread_id();  Deprecated since v2.0.2, use co::thread_id() instead.  #Mutex (Mutex)\rMutex is a kind of mutual exclusion lock commonly used in multithreaded programming. At the same time, at most one thread holds the lock, and other threads must wait for the lock to be released.\n#Mutex::Mutex\rMutex();  Constructor, allocate system resources and initialize.  #Mutex::~Mutex\rMutex::~Mutex();  Destructor, release system resources.  #Mutex::lock\rvoid lock();  Acquire the lock, the method will block until the lock is successfully acquired.  #Mutex::try_lock\rbool try_lock();  Acquire the lock, will not block. If the lock is successfully acquired, it returns true, otherwise it returns false.  #Mutex::unlock\rvoid unlock();  Release the lock, this method is generally called by the thread that held the lock.  #MutexGuard\rThe MutexGuard class is used to automatically acquire and release the lock in Mutex to prevent users from forgetting to release the lock.\n#MutexGuard::MutexGuard\rexplicit MutexGuard(Mutex\u0026amp; m); explicit MutexGuard(Mutex* m);  The constructor, the parameter m is a reference or pointer of the Mutex. When it is a pointer, m MUST NOT be NULL. Internally, m\u0026rsquo;s lock() method is called to acquire the lock.  #MutexGuard::~MutexGuard\rMutexGuard::~MutexGuard();   Destructor, release the lock acquired in the constructor.\n  Example\n  Mutex m; MutexGuard g(m); #SyncEvent\rSyncEvent is a synchronization mechanism between multiple threads, suitable for the producer-consumer model. The consumer calls the wait() method to wait for the synchronization signal, and the producer calls the signal() method to generate the synchronization signal. SyncEvent supports multiple producers and multiple consumers, but in actual applications, there is usually a single consumer.\n#SyncEvent::SyncEvent\rexplicit SyncEvent(bool manual_reset = false, bool signaled = false);  Constructor, the parameter manual_reset indicates whether to manually set the synchronization state to unsynchronized, and the parameter signaled indicates whether the initial state is synchronized.  #SyncEvent::~SyncEvent\rSyncEvent::~SyncEvent();  Destructor, release system resources.  #SyncEvent::reset\rvoid reset();  This method sets SyncEvent to unsynchronized state. When manual_reset is true in the constructor, the user needs to manually call this method after wait() returns, otherwise the SyncEvent may remain in a synchronized state forever.  #SyncEvent::signal\rvoid signal();  This method generates a synchronization signal and sets SyncEvent to a synchronized state.  #SyncEvent::wait\rvoid wait(); bool wait(uint32 ms);  The first version will wait until SyncEvent becomes synchronized. The second version will wait until SyncEvent becomes synchronized or timed out. The parameter ms specifies the timeout period in milliseconds. The second version returns true when the SyncEvent becomes synchronized, and returns false when it timed out. When manual_reset is false in the constructor, SyncEvent will be automatically set to unsynchronized when wait() ends.  #Code example\rbool manual_reset = false; SyncEvent ev(manual_reset);  void f1() {  if (!ev.wait(1000)) {  LOG \u0026lt;\u0026lt; \u0026#34;f1: timedout..\u0026#34;;  } else {  LOG \u0026lt;\u0026lt; \u0026#34;f1: event signaled..\u0026#34;;  if (manual_reset) ev.reset();  } }  void f2() {  LOG \u0026lt;\u0026lt; \u0026#34;f2: send a signal..\u0026#34;;  ev.signal(); }  Thread(f1).detach(); Thread(f2).detach(); #TLS-based thread_ptr\rtemplate \u0026lt;typename T, typename D=std::default_delete\u0026lt;T\u0026gt;\u0026gt; class thread_ptr; The thread_ptr class is similar to std::unique_ptr, but uses the TLS mechanism internally, and each thread sets and owns its own ptr.\n#thread_ptr::thread_ptr\rthread_ptr();  Constructor, allocate system resources and initialize.  #thread_ptr::~thread_ptr\rthread_ptr::~thread_ptr();  Destructor, delete the private ptr of each thread, and release TLS related system resources.  #thread_ptr::get\rT* get() const;  Return the ptr of the current thread. If the thread has not set a ptr before, this method returns NULL.  #thread_ptr::operator=\rvoid operator=(T* p);  Assignment, set the current thread\u0026rsquo;s ptr to p, which is equivalent to reset(p).  #thread_ptr::operator-\u0026gt;\rT* operator-\u0026gt;() const;  Overload operator-\u0026gt;, returns the ptr of the current thread.  #thread_ptr::operator*\rT\u0026amp; operator*() const;  Overload operator*, returns the reference of the object pointed to by the ptr of the current thread.  #thread_ptr::operator==\rbool operator==(T* p) const;  Determine whether the current thread\u0026rsquo;s ptr is equal to p.  #thread_ptr::operator!=\rbool operator!=(T* p) const;  Determine whether the current thread\u0026rsquo;s ptr is not equal to p.  #thread_ptr::operator!\rbool operator!() const;  Determine whether the ptr of the current thread is NULL, return true if it is NULL, otherwise return false.  #thread_ptr::operator bool\rexplicit operator bool() const;  Convert thread_ptr to bool type. If the internal pointer is not NULL, return true, otherwise return false.  #thread_ptr::release\rT* release();  Release the ptr of the current thread. This method sets the ptr of the current thread to NULL and returns the previous ptr.  #thread_ptr::reset\rvoid reset(T* p = 0);  Reset the ptr of the current thread to p, p is 0 by default, and the previous ptr will be deleted by D()(x).  #Code example\rstruct T {  T(int v): _v(v) {}  void run() {  LOG \u0026lt;\u0026lt; current_thread_id() \u0026lt;\u0026lt; \u0026#34;v:\u0026#34; \u0026lt;\u0026lt; _v;  }  int _v; };  thread_ptr\u0026lt;T\u0026gt; pt;  // Each thread will set its own pointer, and different threads will not affect each other void f(int v) {  if (pt == NULL) {  LOG \u0026lt;\u0026lt; \u0026#34;new T(\u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;)\u0026#34;;  pt.reset(new T(v));  }  pt-\u0026gt;run(); }  Thread(f, 1).detach(); // start thread 1 Thread(f, 2).detach(); // start thread 2 "},{"id":15,"href":"/en/co/coroutine/","title":"Coroutine","section":"Documents for CO","content":"include: co/co.h.\n#Basic concepts\r Coroutines are lightweight scheduling units that run in threads. Coroutines are to threads, similar to threads to processes. There can be multiple threads in a process and multiple coroutines in a thread. The thread where the coroutine runs in is generally called the scheduling thread. The scheduling thread will suspend a coroutine, if it blocks on an I/O operation or sleep was called in the coroutine. When a coroutine is suspended, the scheduling thread will switch to other coroutines waiting to be executed. Switching of coroutines is done in user mode, which is faster than switching between threads.  Coroutines are very suitable for network programming, and can achieve synchronous programming without asynchronous callbacks, which greatly reduces the programmer\u0026rsquo;s mental burden.\nco implements a golang style coroutine with the following features:\n Support multi-thread scheduling, the default number of threads is the number of system CPU cores. Coroutines in the same thread share several stacks (the default size is 1MB), and the memory usage is low. Test on Linux shows that 10 millions of coroutines only take 2.8G of memory (for reference only). Once a coroutine is created, it always runs in the same thread. There is a flat relationship between coroutines, and new coroutines can be created from anywhere (including in coroutines).  The coroutine library is based on epoll, kqueue, iocp.\nThe relevant code for context switching is taken from tbox by ruki, and tbox refers to the implementation of boost, thanks here!\n#Coroutine API\r#co::init\rvoid init(); void init(int argc, char** argv); void init(const char* config);  Added since v2.0.2, used to initialize the coroutine library. The first version performs some initialization work inside the coroutine library. The second version first calls flag::init(argc, argv) and log::init(), and then calls co::init() to initialize the coroutine library. The third version first calls flag::init(config) and log::init(), and then calls co::init() to initialize the coroutine library.  #co::exit\rvoid exit();   Added in v2.0.2, stop the coroutine scheduling threads and reclaim system resources.\n  If co::init(argc, argv) or co::init(config) was called before, this function will also call log::exit() to stop the logging thread.\n  It is generally recommended to call this function at the end of the main() function.\n  Code example\n  #include \u0026#34;co/co.h\u0026#34; int main(int argc, char** argv) {  co::init(argc, argv);  // user code  co::exit();  return 0; } #go\rvoid go(Closure* cb); template\u0026lt;typename F\u0026gt; void go(F\u0026amp;\u0026amp; f); template\u0026lt;typename F, typename P\u0026gt; void go(F\u0026amp;\u0026amp; f, P\u0026amp;\u0026amp; p); template\u0026lt;typename F, typename T, typename P\u0026gt; void go(F\u0026amp;\u0026amp; f, T* t, P\u0026amp;\u0026amp; p);   This function is used to create a coroutine, similar to creating a thread, a coroutine function must be specified.\n  In the first version, the parameter cb points to a Closure object. When the coroutine is started, the run() method of Closure will be called.\n  The 2-4th version, pack the incoming parameters into a Closure, and then call the first version.\n  In the second version, the parameter f is any runnable object, as long as we can call f() or (*f)().\n  In the third version, the parameter f is any runnable object, as long as we can call f(p), (*f)(p) or (p-\u0026gt;*f)().\n  In the fourth version, the parameter f is a method with one parameter in the class T, the parameter t is a pointer to class T, and p is the parameter of f.\n  Creating object of std::function is expensive and should be used as little as possible.\n  Strictly speaking, the go() function just assigns a Closure to a scheduling thread, and the actual creation of the coroutine is done by the scheduling thread. But from the user\u0026rsquo;s point of view, logically it can be considered that go() creates a coroutine.\n  Example\n  go(f); // void f(); go(f, 7); // void f(int); go(\u0026amp;T::f, \u0026amp;o); // void T::f(); T o; go(\u0026amp;T::f, \u0026amp;o, 3); // void T::f(int); T o;  // lambda go([](){  LOG \u0026lt;\u0026lt; \u0026#34;hello co\u0026#34;; });  // std::function std::function\u0026lt;void()\u0026gt; x(std::bind(f, 7)); go(x); go(\u0026amp;x); // Ensure that x is alive when the coroutine is running. #DEF_main\rThis macro is used to define the main function and make code in the main function also run in coroutine. DEF_main has already called co::init(argc, argv) for initialization, and users do not need to call it again.\n Example  DEF_main(argc, argv) {  go([](){  LOG \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34;;  });  co::sleep(100); } #co::all_schedulers\rconst std::vector\u0026lt;Scheduler*\u0026gt;\u0026amp; all_schedulers();  Return a reference to the Scheduler list, one Scheduler corresponds to one scheduling thread.  #co::scheduler\rScheduler* scheduler();  Return the scheduler pointer of the current thread. If the current thread is not a scheduling thread, the return value is NULL. This function is generally called in a coroutine to get the scheduler where it runs in.  #co::next_scheduler\rScheduler* next_scheduler();   This function returns the next Scheduler pointer.\n  go(...) is actually equivalent to co::next_scheduler()-\u0026gt;go(...).\n  Example\n  // create coroutines in the same thread auto s = co::next_scheduler(); s-\u0026gt;go(f1); s-\u0026gt;go(f2); #co::scheduler_num\rint scheduler_num();   Returns the number of schedulers. This function is usually used to implement some coroutine-safe data structures.\n  Example\n  std::vector\u0026lt;T\u0026gt; v(co::scheduler_num());  void f() {  // get object for the current scheduler  auto\u0026amp; t = v[co::scheduler_id()]; }  go(f); #co::scheduler_id\rint scheduler_id();  Returns the scheduler id of the current thread. This value is between 0 and co::scheduler_num()-1. If the current thread is not a scheduling thread, the return value is -1. This function is generally called in the coroutine to obtain the id of the scheduler where it runs in.  #co::coroutine_id\rint coroutine_id();  This function returns the id of the current coroutine. Different coroutines have different ids. This function is generally called in a coroutine. When called in a non-coroutine, the return value is -1. There is a simple linear correspondence between the coroutine id and the scheduler id. Assuming there are 4 schedulers, the ids are 0, 1, 2, 3, and the coroutine ids in these schedulers are:  4k (0, 4, 8, ...) 4k + 1 (1, 5, 9, ...) 4k + 2 (2, 6, 10, ...) 4k + 3 (3, 7, 11, ...) #co::sleep\rvoid sleep(uint32 ms);  Let the current coroutine sleep for a while, the parameter ms is time in milliseconds. This function is generally called in a coroutine, calling in a non-coroutine is equivalent to sleep::ms(ms).  #co::stop\rvoid stop();  The same as co::exit(). Deprecated since v2.0.2, use co::exit() instead.  #co::timeout\rbool timeout();  This function checks whether the previous IO operation has timed out. After users call an function like co::recv() with a timeout, they can call this function to determine whether it has timed out. This function must be called in the coroutine.  #Code example\r// print scheduler id and coroutine id every 3 seconds void f() {  while (true) {  LOG \u0026lt;\u0026lt; \u0026#34;s: \u0026#34;\u0026lt;\u0026lt; co::scheduler_id() \u0026lt;\u0026lt;\u0026#34; c: \u0026#34;\u0026lt;\u0026lt; co::coroutine_id();  co::sleep(3000);  } }  int main(int argc, char** argv) {  flag::init(argc, argv);  log::init();  FLG_cout = true; // also log to terminal   for (int i = 0; i \u0026lt;32; ++i) go(f);   while (true) sleep::sec(1024);  return 0; } #Coroutineized socket API\rco provides commonly used coroutineized socket APIs to support coroutine-based network programming.\nMost of the APIs are consistent in form with the native socket APIs, which can reduce the user\u0026rsquo;s learning burden, and users who are familiar with socket programming can easily get started.\nMost of these APIs need to be used in coroutines. When they are blocked on I/O or sleep, the scheduling thread will suspend the current coroutine and switch to other waiting coroutines, and the scheduling thread itself will not block. With these APIs, users can easily implement high-concurrency and high-performance network programs.\n#Terminology convention\rBlocking\nWhen describing some socket APIs in co, the term blocking is used, such as accept, recv. The document says that they will block, which means that the current coroutine will block, but the scheduling thread will not (it can switch to other coroutines to run). From the user\u0026rsquo;s point of view, they saw the coroutines which may block. In fact, these APIs use non-blocking socket internally, which does not really block, but when there is no data to read on the socket or data cannot be written immediately, the scheduling thread will suspend the current coroutine. When the socket becomes readable or writable, the scheduling thread will awaken the coroutine again and continue the I/O operation.\nnon-blocking socket\nThe socket API in co must use non-blocking socket. On windows, socket must also support overlapped I/O, which is supported by default for sockets created with win32 API, users generally no need to worry about it. For narrative convenience, when non-blocking socket is mentioned in the document, it also means that it supports overlapped I/O on windows.\n#co::socket\rsock_t socket(int domain, int type, int proto); sock_t tcp_socket(int domain=AF_INET); sock_t udp_socket(int domain=AF_INET);  Create a socket. The form of the first function is exactly the same as the native API. You can use man socket to see the parameter details on linux. The second function creates a TCP socket. The third function creates a UDP socket. The parameter domain is usually AF_INET or AF_INET6, the former means ipv4 and the latter means ipv6. These functions return a non-blocking socket. When an error occurs, the return value is -1.  #co::accept\rsock_t accept(sock_t fd, void* addr, int* addrlen);  Receive the client connection on the specified socket, the parameter fd is a non-blocking socket, and the parameters addr and addrlen are used to receive the client\u0026rsquo;s address information. The initial value of *addrlen is the length of the buffer pointed to by addr. If the user does not need the client address information, addr and addrlen should be set to NULL. This function must be called in the coroutine. This function will block until a new connection comes in or an error occurs. This function returns a non-blocking socket on success, and returns -1 when an error occurs.  #co::bind\rint bind(sock_t fd, const void* addr, int addrlen);  Bind the ip address to the socket, the parameters addr and addrlen are the address information, which is the same as the native API. This function returns 0 on success, otherwise returns -1.  #co::close\rint close(sock_t fd, int ms=0);  Close the socket. In CO v2.0.0 or before, a socket MUST be closed in the same thread that performed the I/O operation. Since v2.0.1, a socket can be closed anywhere. When the parameter ms \u0026gt; 0, first call co::sleep(ms) to suspend the current coroutine for a period of time, and then close the socket. The EINTR signal has been processed internally in this function, and the user does not need to consider it. This function returns 0 on success, otherwise it returns -1.  #co::connect\rint connect(sock_t fd, const void* addr, int addrlen, int ms=-1);  Create a connection to the specified address on the specified socket, the parameter fd must be non-blocking, the parameter ms is the timeout period in milliseconds, the default is -1, which will never time out. This function must be called in the coroutine. This function will block until the connection is completed, or timeout or an error occurs. This function returns 0 on success, and returns -1 on timeout or an error occurs. The user can call co::timeout() to check whether it has timed out.  #co::listen\rint listen(sock_t fd, int backlog=1024);  Listenning on the specified socket. This function returns 0 on success, otherwise it returns -1.  #co::recv\rint recv(sock_t fd, void* buf, int n, int ms=-1);  Receive data on the specified socket, the parameter fd must be non-blocking, the parameter buf is the buffer to receive the data, the parameter n is the buffer length, and the parameter ms is the timeout period in milliseconds, the default is -1, never time out. This function must be called in the coroutine. On Windows, this function only works with TCP-like stream socket. This function will block until any data comes in, or timeout or any error occurs. This function returns length of the data received (may be less than n) on success, returns 0 when the peer closes the connection, returns -1 when timeout or an error occurs, and users can call co::timeout() to check whether it has timed out.  #co::recvn\rint recvn(sock_t fd, void* buf, int n, int ms=-1);  Receive data of the specified length on the specified socket, the parameter fd must be non-blocking, the parameter ms is the timeout period in milliseconds, the default is -1, never timeout. This function must be called in the coroutine. This function will block until all n bytes of data are received, or timeout or an error occurs. This function returns n on success, returns 0 when the peer closes the connection, and returns -1 when timeout or an error occurs. The user can call co::timeout() to check whether it has timed out.  #co::recvfrom\rint recvfrom(sock_t fd, void* buf, int n, void* src_addr, int* addrlen, int ms=-1);  Similar to recv(), except that the parameters src_addr and addrlen can be used to receive the source address information. The initial value of *addrlen is the length of the buffer pointed to by src_addr. If the user does not need the source address information, addr and addrlen should be set to NULL . Generally it is recommended to use this function to receive UDP data only, for TCP data, use recv() or recvn() instead.  #co::send\rint send(sock_t fd, const void* buf, int n, int ms=-1);  Send data to the specified socket, the parameter fd must be non-blocking, the parameter ms is the timeout period in milliseconds, the default is -1, which will never time out. This function must be called in the coroutine. On Windows, this function only works with TCP-like stream socket. This function will block until all n bytes of data are sent, or timeout or an error occurs. This function returns n on success, and returns -1 on timeout or an error occurs. The user can call co::timeout() to check whether it has timed out.  #co::sendto\rint sendto(sock_t fd, const void* buf, int n, const void* dst_addr, int addrlen, int ms=-1);  Send data to the specified address. When dst_addr is NULL and addrlen is 0, it is equivalent to send(). Generally it is recommended to use this function to send UDP data only, for TCP data, use send() instead. When fd is a UDP socket, the maximum n is 65507.  #co::shutdown\rint shutdown(sock_t fd, char c=\u0026#39;b\u0026#39;);  This function is generally used to half-close the socket. The parameter c is a hint, 'r' for read, 'w' for write, the default is 'b', which means both reading and writing are closed. It is better to call this function in the same thread that performed the I/O operation. This function returns 0 on success, otherwise it returns -1.  #co::error\rint error();  Return the current error code. When the socket API in CO returns -1, the user can call this function to get the error code.  #co::strerror\rconst char* strerror(int err); const char* strerror();  Get the error string corresponding to the error code. It is thread safe. The second version gets the description information of the current error, which is equivalent to strerror(co::error()).  #co::set_error\rvoid set_error(int err);  Set the current error code, users generally do not need to call this function.  #———————————\r#co::getsockopt\rint getsockopt(sock_t fd, int lv, int opt, void* optval, int* optlen);  Get socket option information, which is exactly the same as native API, man getsockopt for details.  #co::setsockopt\rint setsockopt(sock_t fd, int lv, int opt, const void* optval, int optlen);  Set the socket option information, which is exactly the same as the native API, man setsockopt for details.  #co::set_nonblock\rvoid set_nonblock(sock_t fd);  Set O_NONBLOCK option for the socket.  #co::set_reuseaddr\rvoid set_reuseaddr(sock_t fd);  Set SO_REUSEADDR option for the socket. Generally, the listening socket of a server needs to set this option, or the bind() may fail when the server restarts.  #co::set_recv_buffer_size\rvoid set_recv_buffer_size(sock_t fd, int n);  Set the receiving buffer size of the socket. This function must be called before the socket is connected.  #co::set_send_buffer_size\rvoid set_send_buffer_size(sock_t fd, int n);  Set the size of the sending buffer of the socket. This function must be called before the socket is connected.  #co::set_tcp_keepalive\rvoid set_tcp_keepalive(sock_t fd);  Set SO_KEEPALIVE option for the socket.  #co::set_tcp_nodelay\rvoid set_tcp_nodelay(sock_t fd);  Set TCP_NODELAY option for the socket.  #co::reset_tcp_socket\rint reset_tcp_socket(sock_t fd, int ms=0);  Reset a TCP connection, similar to co::close(), but the caller will not enter the TIME_WAIT state. Generally, only the server side will call this function to close a client connection without entering the TIME_WAIT state.  #———————————\r#co::init_ip_addr\rbool init_ip_addr(struct sockaddr_in* addr, const char* ip, int port); bool init_ip_addr(struct sockaddr_in6* addr, const char* ip, int port);   Initialize the sockaddr structure with ip and port.\n  The first version is used for ipv4 addresses, and the second version is used for ipv6 addresses.\n  Example\n  union {  struct sockaddr_in v4;  struct sockaddr_in6 v6; } addr;  co::init_ip_addr(\u0026amp;addr.v4, \u0026#34;127.0.0.1\u0026#34;, 7777); co::init_ip_addr(\u0026amp;addr.v6, \u0026#34;::\u0026#34;, 7777); #co::ip_str\rfastring ip_str(const struct sockaddr_in* addr); fastring ip_str(const struct sockaddr_in6* addr);   Get the ip string from the sockaddr structure.\n  The first version is used for ipv4 addresses, and the second version is used for ipv6 addresses.\n  Example\n  struct sockaddr_in addr; co::init_ip_addr(\u0026amp;addr, \u0026#34;127.0.0.1\u0026#34;, 7777); auto s = co::ip_str(\u0026amp;addr); // s -\u0026gt; \u0026#34;127.0.0.1\u0026#34; #co::to_string\rfastring to_string(const struct sockaddr_in* addr); fastring to_string(const struct sockaddr_in6* addr); fastring to_string(const void* addr, int addrlen);   Convert the sockaddr address into a string in the form of \u0026quot;ip:port\u0026quot;.\n  The first version is used for ipv4 addresses, and the second version is used for ipv6 addresses.\n  The third version calls version 1 or version 2 according to addrlen.\n  Example\n  struct sockaddr_in addr; co::init_ip_addr(\u0026amp;addr, \u0026#34;127.0.0.1\u0026#34;, 7777); auto s = co::to_string(\u0026amp;addr); // s -\u0026gt; \u0026#34;127.0.0.1:7777\u0026#34; #co::peer\rfastring peer(sock_t fd);  Get the address information of the peer. The return value is a string in the form of \u0026quot;ip:port\u0026quot;.  #co::Chan\rco::Chan is a template class, it is similar to channel in golang, which is used to share data between coroutines.\ntemplate \u0026lt;typename T\u0026gt; class Chan;  co::Chan is implemented based on memory copy. The template parameter T can be built-in type, pointer type, or structure with simple memory copy semantics for the copy operation. In short, T must meet the following condition: for two variables or objects a and b of type T, a = b is equivalent to memcpy(\u0026amp;a, \u0026amp;b, sizeof(T)). For type like std::string or STL containers, the copy operation is not a simple memory copy, so it cannot be transferred directly in the channel.  #Chan::Chan\rexplicit Chan(uint32 cap=1, uint32 ms=(uint32)-1); Chan(Chan\u0026amp;\u0026amp; c); Chan(const Chan\u0026amp; c);  In the first constructor, the parameter cap is the maximum capacity of the internal queue, the default is 1, and the parameter ms is the timeout for read and write operations in milliseconds, and the default is -1, which will never time out. The second is the move constructor, and we can put co::Chan into STL containers. The third is the copy constructor, which only increases the internal reference count by 1.  #operator\u0026laquo;\rtemplate \u0026lt;typename T\u0026gt; void operator\u0026lt;\u0026lt;(const T\u0026amp; x) const;  Write operation, it must be performed in coroutine. This method will block until the write operation is completed or timed out. co::timeout() can be called to check whether it has timed out.  #operator\u0026raquo;\rtemplate \u0026lt;typename T\u0026gt; void operator\u0026gt;\u0026gt;(T\u0026amp; x) const;  Read operation, it must be performed in coroutine. This method will block until the read operation is completed or timed out. co::timeout() can be called to check whether it has timed out.  #Code example\r#include \u0026#34;co/co.h\u0026#34; void f() {  co::Chan\u0026lt;int\u0026gt; ch;  go([ch]() {ch \u0026lt;\u0026lt; 7; });  int v = 0;  ch \u0026gt;\u0026gt; v;  LOG \u0026lt;\u0026lt; \u0026#34;v: \u0026#34;\u0026lt;\u0026lt; v; }  void g() {  co::Chan\u0026lt;int\u0026gt; ch(32, 500);  go([ch]() {  ch \u0026lt;\u0026lt; 7;  if (co::timeout()) LOG \u0026lt;\u0026lt; \u0026#34;write to channel timeout..\u0026#34;;  });   int v = 0;  ch \u0026gt;\u0026gt; v;  if (!co::timeout()) LOG \u0026lt;\u0026lt; \u0026#34;v: \u0026#34;\u0026lt;\u0026lt; v; }  DEF_main(argc, argv) {  f();  g();  return 0; } In the above code, the channel object is on the stack, so we capture by value in the lambda and copy the channel to the coroutine.\n#co::Event\rco::Event is a synchronization mechanism between coroutines. It is similar to SyncEvent in threads. Since co 2.0.1, co::Event can be used in both coroutines and non-coroutines.\n#Event::Event\rEvent(); Event(Event\u0026amp;\u0026amp; e); Event(const Event\u0026amp; e);  The first is the default constructor. The second is the move constructor, which supports putting co::Event into the STL container. The third is the copy constructor, which only increases the internal reference count by one.  #Event::signal\rvoid signal() const;  Generate a signal, and co::Event turns to synchronized state, all waiting coroutines will be awaken. If co::Event currently has no waiting coroutine, the next coroutine that calls the wait() method will return immediately. This method can be called anywhere.  #Event::wait\rvoid wait() const; bool wait(unsigned int ms) const;  Wait for the synchronization signal. If co::Event is currently unsynchronized, the calling coroutine will enter a waiting state. In co 2.0.0 or before, it must be called in coroutine. Since 2.0.1, it can be called anywhere. The first version will block until co::Event becomes synchronized. The second version will block until co::Event becomes synchronized or timed out. The parameter ms is the timeout period in milliseconds. It returns false when timeout, otherwise returns true.  #Code example\rco::Event ev;  // capture by value, as data on stack may be overwritten by other coroutines. go([ev](){  ev.signal(); });  ev.wait(100); // wait for 100 ms #co::WaitGroup\rco::WaitGroup is similar to sync.WaitGroup in golang, which can be used to wait for coroutines or threads to exit.\n#WaitGroup::WaitGroup\rWaitGroup(); WaitGroup(WaitGroup\u0026amp;\u0026amp; wg); WaitGroup(const WaitGroup\u0026amp; wg);  The first is the default constructor. The second is the move constructor, which supports putting co::WaitGroup into the STL container. The third is the copy constructor, which only increases the internal reference count by one.  #WaitGroup::add\rvoid add(uint32 n=1) const;  Increase the internal counter by n, the default value of n is 1. It is thread-safe and can be called anywhere.  #WaitGroup::done\rvoid done() const;  Decrement the internal counter by 1. It is thread-safe and can be called anywhere. It is usually called at the end of coroutine or thread function.  #WaitGroup::wait\rvoid wait() const;  Wait until the value of the internal counter becomes 0.  #Code example\r#include \u0026#34;co/co.h\u0026#34; DEF_main(argc, argv) {  co::WaitGroup wg;  wg.add(8);   for (int i = 0; i \u0026lt; 8; ++i) {  go([wg]() {  LOG \u0026lt;\u0026lt; \u0026#34;co: \u0026#34; \u0026lt;\u0026lt; co::coroutine_id();  wg.done();  });  }   wg.wait();  return 0; } #co::Mutex\rco::Mutex is a mutex lock for coroutines, similar to Mutex for threads, but needs to be used in coroutine environments.\n#Mutex::Mutex\rMutex(); Mutex(Mutex\u0026amp;\u0026amp; m); Mutex(const Mutex\u0026amp; m);  The first is the default constructor. The second is the move constructor. You can put co::Mutex into STL containers. The third is the copy constructor, which only increases the internal reference count by one.  #Mutex::lock\rvoid lock() const;  Acquire the lock, must be called in coroutine. It blocks until the lock is acquired.  #Mutex::try_lock\rbool try_lock() const;  Acquire the lock, will not block. It returns true when the lock is successfully acquired, otherwise it returns false. This method can be called anywhere, but it is usually called in coroutine.  #Mutex::unlock\rvoid unlock() const;  Release the lock, which can be called from anywhere. It is usually called in the coroutine that held the lock in a well-designed program.  #co::MutexGuard\r#MutexGuard::MutexGuard\rexplicit MutexGuard(co::Mutex\u0026amp; m); explicit MutexGuard(co::Mutex* m);  Constructor, call m.lock() to acquire the lock, the parameter m is a reference or pointer of the co::Mutex.  #MutexGuard::~MutexGuard\r~MutexGuard();  Destructor, release the lock acquired in the constructor.  #Code example\rco::Mutex mtx; int v = 0;  void f1() {  co::MutexGuard g(mtx);  ++v; }  void f2() {  co::MutexGuard g(mtx);  --v; }  go(f1); go(f2); #co::Pool\rco::Pool is a general coroutine pool, which is coroutine safe. It stores pointers of type void* internally, which can be used as connection pool, memory pool or cache for other purposes.\n#Pool::Pool\rPool(); Pool(Pool\u0026amp;\u0026amp; p); Pool(const Pool\u0026amp; p); Pool(std::function\u0026lt;void*()\u0026gt;\u0026amp;\u0026amp; ccb, std::function\u0026lt;void(void*)\u0026gt;\u0026amp;\u0026amp; dcb, size_t cap=(size_t)-1);   The first is the default constructor. Compared with the 4th version, ccb and dcb are NULL.\n  The second is the move constructor.\n  The third is the copy constructor, which only increases the internal reference count by one.\n  In the 4th version, the parameter ccb is used to create an element, and dcb is used to destroy an element. The parameter cap specifies the maximum capacity of the pool, and the default is -1 for unlimited.\n  Note that the parameter cap is not the total capacity, but for a single thread. If cap is set to 1024 and there are 8 scheduling threads, the total capacity is 8192. In addition, when dcb is NULL, cap will be ignored. This is because when the number of elements exceeds the maximum capacity, co::Pool needs to call dcb to destroy the extra elements.\n  Example\n  class T; co::Pool p(  []() {return (void*) new T; }, // ccb  [](void* p) {delete (T*) p;} // dcb ); #Pool::clear\rvoid clear() const;  Clear all pools in co::Pool, it can be called anywhere. If dcb is set, it will be used to destroy the elements in co::Pool.  #Pool::pop\rvoid* pop() const;  Pop an element from co::Pool, it must be called in coroutine. When co::Pool is empty, if ccb is not NULL, call ccb() to create an element, otherwise it will return NULL. This method is coroutine safe, and we do not need a lock here.  #Pool::push\rvoid push(void* e) const;   Push an element to co::Pool, it must be called in coroutine.\n  If e is NULL, it will be ignored.\n  As each thread has its own pool, push() should be called in the same thread that calls pop().\n  If co::Pool has reached the maximum capacity, and dcb is not NULL, dcb(e) will be called to destroy the element.\n  This method is coroutine safe, and we do not need a lock here.\n  Example\n  class Redis; // assume class Redis is a connection to the redis server co::Pool p;  void f {  Redis* rds = (Redis*) p.pop(); // pop a redis connection  if (rds == NULL) rds = new Redis;  rds-\u0026gt;get(\u0026#34;xx\u0026#34;); // call get() method of redis  p.push(rds); // push rds back to co::Pool }  go(f); #Pool::size\rsize_t size() const;  Returns size of the pool for the current thread. It must be called in coroutine.  #co::PoolGuard\rco::PoolGuard pops an element from co::Pool during construction, and puts it back during destruction. At the same time, it also overloads operator-\u0026gt;, so we can use it like a smart pointer.\ntemplate\u0026lt;typename T, typename D=std::default_delete\u0026lt;T\u0026gt;\u0026gt; class PoolGuard;  The parameter T is the actual type pointed to by pointers in co::Pool, and the parameter D is the deleter, which is used to delete a pointer of type T*.  #PoolGuard::PoolGuard\rexplicit PoolGuard(co::Pool\u0026amp; p); explicit PoolGuard(co::Pool* p);  Constructor, pop an element from co::Pool.  #PoolGuard::~PoolGuard\r~PoolGuard();  Destructor, push the element back into co::Pool.  #PoolGuard::get\rT* get() const;  Get the pointer popped from co::Pool in the constructor.  #PoolGuard::operator-\u0026gt;\rT* operator-\u0026gt;() const;  Overload operator-\u0026gt;, returns the pointer popped from co::Pool in the constructor.  #PoolGuard::operator*\rT\u0026amp; operator*() const;  Overload operator*, returns a reference of object of type T.  #PoolGuard::operator bool\rexplicit operator bool() const;  Convert co::PoolGuard to bool type, if the internal pointer is not NULL, returns true, otherwise returns false.  #PoolGuard::operator!\rbool operator!() const;  Check whether the internal pointer is NULL, return true if it is NULL, otherwise returns false.  #PoolGuard::operator==\rbool operator==(T* p) const;  Check whether the internal pointer is equal to p.  #PoolGuard::operator!=\rbool operator!=(T* p) const;  Check whether the internal pointer is not equal to p.  #PoolGuard::operator=\rvoid operator=(T* p);  Assignment, equivalent to reset(p).  #PoolGuard::reset\rvoid reset(T* p = 0);  Reset the internal pointer, and call D()(x) to delete the original pointer.  #Code example\rclass Redis; // assume class Redis is a connection to the redis server  co::Pool p(  []() {return (void*) new Redis; }, // ccb  [](void* p) {delete (Redis*) p;} // dcb );  void f() {  co::PoolGuard\u0026lt;Redis\u0026gt; rds(p); // now rds can be used like a Redis* pointer.  rds-\u0026gt;get(\u0026#34;xx\u0026#34;); }  go(f); #co::IoEvent\rco::IoEvent is used to convert non-blocking I/O to synchronous mode. When users perform an I/O operation on a non-blocking socket in coroutine, and the socket is unreadable or unwritable, users call the wait() method of co::IoEvent wait for I/O events on the socket, and the coroutine is suspended. When the socket becomes readable or writable, the scheduling thread will resume the coroutine again and continue the I/O operation.\nco 1.x does not expose the co::IoEvent, as it is only used internally. This class is public in co 2.0, which is convenient for users to coroutineize third-party network libraries.\n#co::io_event_t\renum io_event_t {  ev_read = 1,  ev_write = 2, };  enum type, which means I/O event type, co::ev_read for read, and co::ev_write for write.  #IoEvent::IoEvent\rIoEvent(sock_t fd, io_event_t ev); IoEvent(sock_t fd, int n=0); // for windows only  Constructor, linux and mac platforms only provide the first version, windows platform also provides the second version. In the first version, the parameter fd is a non-blocking socket, and the parameter ev is an I/O event, which is one of co::ev_read or co::ev_write. Calling the wait() method will wait for the I/O event specified by ev on the socket. When wait() returns successfully, users need to call recv, send or other I/O functions to complete the I/O operation. On windows, fd must be a TCP socket(For UDP, it is difficult to simulate the behavior of epoll or kqueue with IOCP). The second version is only applicable to windows. Unlike the first version, fd can be a UDP socket, but users must manually call WSARecvFrom, WSASendTo or other functions to post an overlapped I/O operation to IOCP, and then call the wait() method. When wait() returns successfully, it means that IOCP has completed the I/O operation. See details in source code of co::IoEvent, and implementation of co::accept, co::connect, co::recvfrom, co::sendto on windows.  #IoEvent::~IoEvent\r~IoEvent();  Destructor, remove previously registered I/O events from epoll or kqueue.  #IoEvent::wait\rbool wait(int ms=-1);  This method waits for I/O events on the socket. The parameter ms is the timeout in milliseconds, the default is -1, which will never time out. This method blocks until the I/O event arrives, or timeout or an error occurs. This method returns true on success, and returns false when timeout or an error occurs. co::timeout() can be called to check whether it has timed out.  #Code example\rint recv(sock_t fd, void* buf, int n, int ms) {  CHECK(gSched) \u0026lt;\u0026lt; \u0026#34;must be called in coroutine..\u0026#34;;  co::IoEvent ev(fd, co::ev_read);   do {  int r = (int) CO_RAW_API(recv)(fd, buf, n, 0);  if (r != -1) return r;   if (errno == EWOULDBLOCK || errno == EAGAIN) {  if (!ev.wait(ms)) return -1;  } else if (errno != EINTR) {  return -1;  }  } while (true); } The above example is the implementation of co::recv. When the native recv() generates an EWOULDBLOCK or EAGAIN error, use co::IoEvent to wait for the read event. When wait() returns normally, the socket is readable, continue to call the native recv() to complete the read operation .\n#Use third-party network libraries in coroutine\rWhen a third-party network library is used directly in coroutine, it may block the scheduling thread and the scheduling thread will not work normally. There are two ways to solve this problem. The first is to coroutineize third-party libraries, and the second is to hook the system socket APIs.\n#Coroutineization\rCoroutineization requires third-party libraries to provide non-blocking APIs.\nint recv(SSL* s, void* buf, int n, int ms) {  CHECK(co::scheduler()) \u0026lt;\u0026lt; \u0026#34;must be called in coroutine..\u0026#34;;  int r, e;  int fd = SSL_get_fd(s);  if (fd \u0026lt;0) return -1;   do {  ERR_clear_error();  r = SSL_read(s, buf, n);  if (r \u0026gt; 0) return r; // success  if (r == 0) {  DLOG \u0026lt;\u0026lt; \u0026#34;SSL_read return 0, error: \u0026#34;\u0026lt;\u0026lt; SSL_get_error(s, 0);  return 0;  }   e = SSL_get_error(s, r);  if (e == SSL_ERROR_WANT_READ) {  co::IoEvent ev(fd, co::ev_read);  if (!ev.wait(ms)) return -1;  } else if (e == SSL_ERROR_WANT_WRITE) {  co::IoEvent ev(fd, co::ev_write);  if (!ev.wait(ms)) return -1;  } else {  DLOG \u0026lt;\u0026lt; \u0026#34;SSL_read return \u0026#34;\u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#34;, error:\u0026#34; \u0026lt;\u0026lt; e;  return r;  }  } while (true); } The above is an example of coroutineizing SSL_read in openssl. The whole process is relatively simple. The underlying socket must be non-blocking. When SSL_read generates a SSL_ERROR_WANT_READ error, use co::IoEvent to wait for the read event, and when an SSL_ERROR_WANT_WRITE error occurs, use co::IoEvent to wait for the write event. When wait() returns normally, it means that the socket is readable or writable, continue to call SSL_read to complete the I/O operation.\nAt present, CO has successfully coroutineized openssl and libcurl. In theory, all third-party network libraries that provide non-blocking APIs can be coroutineized in a similar way to the above.\n#System API hook\rAPI hook is simply to intercept the system API call. If an API is called in coroutine and a blocking socket is used, the socket is modified to non-blocking mode, and then co::IoEvent or the lower-level interface of CO is used to wait for the I/O event on the socket. When an I/O event arrives, wake up the coroutine to continue the I/O operation.\nSince CO 2.0.1, hook has been supported on Linux, Mac and Windows.\nThe advantage of API hook is that, we only need to hook a small number of system socket APIs, and we can use all third-party libraries that provide blocking APIs in coroutine.\nHowever, coroutineization needs to provide a set of coroutineized APIs for each third-party library, but it has better performance and is safer, and can avoid some problems caused by the complexity of the third-party library.\n#Network programming model based on coroutine\rIt is easy to write high-concurrency and high-performance network programs with coroutine. Although a coroutine may block, the scheduling thread can quickly switch between a large number of coroutines. Therefore, to achieve high concurrency, we just need to create more coroutines.\n#Network model for TCP server\r// recv or send data on the connection void on_connection(int fd) {  while (true) {  co::recv(fd, ...); // recv request from client  process(...); // process the request  co::send(fd, ...); // send response to client  } }  void server_fun() {  while (true) {  int fd = co::accept(...);  if (fd != -1) go(on_connection, fd);  } }  go(server_fun);  One coroutine for each connection. In one coroutine, call co::accept() to accept client connections. When a connection is accepted, create a new coroutine to handle the connection. on_connection() is the coroutine function for handling connections, receiving, processing and sending data are performed in a synchronous manner in the coroutine, and we do not need any asynchronous callback. For complete implementation, please refer to Test code in CO.  #Network model for TCP client\rvoid client_fun() {  while true {  if (!connected) co::connect(...); // connect to the server  co::send(...); // send request to the server  co::recv(...); // recv response from the server  process(...); // process the response  if (over) co::close(...); // close the connection  } }  go(client_fun);   Connecting, sending, recving and processing data are performed in a synchronous manner in the coroutine.\n  For complete implementation, please refer to Test code in CO.\n  In actual applications, co::Pool is generally used as a connection pool to avoid creating too many connections:\nco::Pool pool;  void client_fun() {  while true {  co::PoolGuard\u0026lt;Connection\u0026gt; conn(pool); // get a idle connection from the pool  conn-\u0026gt;send(...); // send request to the server  conn-\u0026gt;recv(...); // recv response from the server  process(...); // process the response  if (over) conn-\u0026gt;close(...); // close the connection  } }  go(client_fun);  co::PoolGuard pops an idle connection from co::Pool during construction, and push it back during destruction.  #Configuration\r#co_debug_log\rDEF_bool(co_debug_log, false, \u0026#34;#1 enable debug log for coroutine library\u0026#34;);  Print debug logs for coroutine, the default is false.  #co_sched_num\rDEF_uint32(co_sched_num, os::cpunum(), \u0026#34;#1 number of coroutine schedulers, default: os::cpunum()\u0026#34;);  The number of scheduling threads, the default is the number of system CPU cores. In the current implementation, the largest value is also the number of system CPU cores.  #co_stack_size\rDEF_uint32(co_stack_size, 1024 * 1024, \u0026#34;#1 size of the stack shared by coroutines, default: 1M\u0026#34;);  The size of the coroutine stack, the default is 1M.  #disable_hook_sleep\rDEF_bool(disable_hook_sleep, false, \u0026#34;#1 disable hook sleep if true\u0026#34;);  Disable hook for sleep related APIs, the default is false.  #hook_log\rDEF_bool(hook_log, false, \u0026#34;#1 enable log for hook if true\u0026#34;);  Print logs for hook, the default is false.  "},{"id":16,"href":"/en/co/net/byte_order/","title":"Byte order","section":"Network Programming","content":"include: co/byte_order.h.\nData in the computer is stored in bytes (8 bit). Big-endian computers use big-endian byte order, that is, the high-order byte is at the lower address, and the low-order byte is at the higher address. The little-endian machine uses little-endian byte order, that is, the low-order byte is at the lower address, and the high-order byte is at the higher address.\nA single byte is exactly the same on big endian and little endian machines, while the basic data types of multiple bytes have are different. The basic data types mentioned here refer to built-in types like int, double. String is not included here, as it is a sequence of single byte and have the same storage format on big or little endian machines.\nThe data transmitted on network is in big-endian byte order, which is also called network byte order. When sending data to the network, the basic multi-byte type needs to be converted into network byte order, and when receiving data from the network, it needs to be converted into the byte order of the host.\nbyte_order.h defines the following methods:\nntoh16 ntoh32 ntoh64 hton16 hton32 hton64 These methods are applicable to integers with lengths of 2, 4, and 8 bytes. The ntoh series converts network byte order to host byte order, and the hton series converts host byte order to network byte order. .\n Code example  uint32 h = 777; uint32 n = hton32(h); "},{"id":17,"href":"/en/co/net/tcp/","title":"TCP","section":"Network Programming","content":"include: co/so/tcp.h.\n#tcp::Connection\rtcp::Connection is a simple encapsulation of TCP connection, it is designed for TCP server. When SSL is enabled in a TCP server, tcp::Connection will transfer data by SSL.\n#Connection::Connection\rConnection(int sock); Connection(void* ssl); Connection(Connection\u0026amp;\u0026amp; c);  The constructor, Connection is created by tcp::Server, users do not need to create it manually. The first version constructs a normal TCP connection, the second version constructs a TCP connection that support SSL, and the third is a move constructor.  #Connection::~Connection\rConnection::~Connection();  Destructor, call close() to close the connection.  #Connection::close\rint close(int ms = 0);  Close the connection. When the parameter ms \u0026gt; 0, close the connection after a certain delay. Since v2.0.1, this method can be called anywhere(in coroutine or non-coroutine).  #Connection::recv\rint recv(void* buf, int n, int ms=-1);  Receive data, similar to co::recv. This method must be called in the coroutine. Return \u0026gt; 0 on success, \u0026lt; 0 on timeout or any error, and 0 will be returned if the peer closed the connection.  #Connection::recvn\rint recvn(void* buf, int n, int ms=-1);  Receive data of specified length, similar to co::recvn. Return n on success, \u0026lt; 0 on timeout or any error, and 0 will be returned if the peer closed the connection.  #Connection::reset\rint reset(int ms = 0)  Reset the TCP connection, unlike close(), it will not enter the TIME_WAIT state. When the parameter ms \u0026gt; 0, the connection will be reset after a certain delay. This method must be called in the I/O thread (usually a coroutine that performs the I/O operations).  #Connection::send\rint send(const void* buf, int n, int ms=-1);  Send data, similar to co::send(). return n on success, \u0026lt;= 0 on timeout or error.  #Connection::socket\rint socket() const;  Return the internal socket descriptor, -1 will be returned if the connection was closed.  #Connection::strerror\rconst char* strerror() const;  When an error occurs in a method of Connection, the user can call this method to get the error message.  #tcp::Server\rtcp::Server is a TCP server based on coroutine. It has the following features:\n Support IPv4 and IPv6. Support SSL (openssl is required). One coroutine for each client connection.  #Server::Server\rServer();  The constructor, initialization.  #Server::on_connection\rvoid on_connection(std::function\u0026lt;void(Connection)\u0026gt;\u0026amp;\u0026amp; f); void on_connection(const std::function\u0026lt;void(Connection)\u0026gt;\u0026amp; f); template\u0026lt;typename T\u0026gt; void on_connection(void (T::*f)(Connection), T* o);   Set a callback for handling connections.\n  In the first 2 versions, the parameter f is a function of type void f(Connection), or a function object of type std::function\u0026lt;void(Connection)\u0026gt;.\n  In the third version, the parameter f is a method in the class T, and the parameter o is a pointer to type T.\n  Since v2.0.2, the parameter of f is an object of tcp::Connection, rather than a pointer, and users do not need to delete it any more.\n  When the server receives a connection, it will create a new coroutine and call the callback set by this method in the coroutine to handle the connection.\n  Example\n  void f(tcp::Connection conn);  tcp::Server s; s.on_connection(f);  void f(tcp::Connection conn) {  while (true) {  conn.recv(...);  process(...);  conn.send(...);  }   conn.close(); } #Server::start\rvoid start(const char* ip, int port, const char* key=0, const char* ca=0);  Start the TCP server, this method will not block the current thread. The parameter ip is the server ip, which can be an IPv4 or IPv6 address, and the parameter port is the server port. The parameter key is path of a PEM file which stores the SSL private key, and the parameter ca is path of a PEM file which stores the SSL certificate. They are NULL by default, and SSL is disabled.  #Server::exit\rvoid exit();  Added since v2.0.2. Exit the TCP server, close the listening socket, and no longer receive new connections. This method will not close the connections that has been established before.  #tcp::Client\rtcp::Client is a TCP client based on coroutine. It has following features:\n Support IPv4 and IPv6. Support SSL (openssl is required). One client corresponds to one connection. It must be used in coroutine. It is not coroutine-safe, and it cannot be used by multiple coroutines at the same time.  #Client::Client\rClient(const char* ip, int port, bool use_ssl=false); Client(const Client\u0026amp; c);  Constructor. The parameter ip is the ip of the server, which can be a domain name, or an IPv4 or IPv6 address; the parameter port is the server port; the parameter use_ssl indicates whether to enable SSL transmission, the default is false, and SSL is not enabled. The second version is the copy constructor, value of ip, port and use_ssl will be copied from another client. The connection is not established in the constructor. It is generally recommended to check whether the connection has been established before calling recv, send. If not, call the connect() method to establish the connection. It is easy to support auto-reconnection in this way.  #Client::~Client\rClient::~Client();  Destructor, call the disconnect() method to close the connection.  #Client::close\rvoid close();  Close the connection, same as disconnect().  #Client::connect\rbool connect(int ms);  Establish a connection, the parameter ms is the timeout period in milliseconds. This method must be called in the coroutine. This method returns true on success, otherwise it returns false. When it fails, the user can use the strerror() method to get the error message.  #Client::connected\rbool connected() const;  Determine whether the connection has been established.  #Client::disconnect\rvoid disconnect();  Since v2.0.1, it can be called anywhere(in coroutine or non-coroutine). It is safe to call this method multiple times, and it will be called automatically in the destructor.  #Client::recv\rint recv(void* buf, int n, int ms=-1);  Receive data, similar to co::recv(). This method must be called in the coroutine. Return \u0026gt; 0 on success, \u0026lt; 0 on timeout or any error, and 0 will be returned if the peer closed the connection.  #Client::recvn\rint recvn(void* buf, int n, int ms=-1);  Receive data of specified length, similar to co::recvn(). This method must be called in the coroutine. Return n on success, \u0026lt; 0 on timeout or any error, and 0 will be returned if the peer closed the connection.  #Client::send\rint send(const void* buf, int n, int ms=-1);  Send data, similar to co::send(). This method must be called in the coroutine. return n on success, \u0026lt;= 0 on timeout or error.  #Client::socket\rint socket() const;  Return the internal socket descriptor. When the connection is not established or the connection has been closed, the return value is -1.  #Client::strerror\rconst char* strerror() const;  When an error occurs in a method of tcp::Client, the user can call this method to get the error message.  #TCP server example\rvoid on_connection(tcp::Connection conn) {  char buf[8] = { 0 };   while (true) {  int r = conn.recv(buf, 8);  if (r == 0) { /* client close the connection */  conn.close();  break;  } else if (r \u0026lt; 0) { /* error */  conn.reset(3000);  break;  } else {  LOG \u0026lt;\u0026lt; \u0026#34;server recv \u0026#34; \u0026lt;\u0026lt; fastring(buf, r);  LOG \u0026lt;\u0026lt; \u0026#34;server send pong\u0026#34;;  r = conn.send(\u0026#34;pong\u0026#34;, 4);  if (r \u0026lt;= 0) {  LOG \u0026lt;\u0026lt; \u0026#34;server send error: \u0026#34; \u0026lt;\u0026lt; conn.strerror();  conn.reset(3000);  break;  }  }  } }  tcp::Server s; s.on_connection(on_connection); s.start(\u0026#34;0.0.0.0\u0026#34;, 7788); // no ssl s.start(\u0026#34;0.0.0.0\u0026#34;, 7788, \u0026#34;privkey.pem\u0026#34;, \u0026#34;certificate.pem\u0026#34;); // use ssl  The above example implements a simple ping-pong server, when it receives a ping sent by the client, it will reply with a pong.  #TCP client code example\rbool use_ssl = false; std::unique_ptr\u0026lt;tcp::Client\u0026gt; proto;  co::Pool pool(  []() {return (void*) new tcp::Client(*proto); },  [](void* p) {delete (tcp::Client*) p;} );  void client_fun() {  co::PoolGuard\u0026lt;tcp::Client\u0026gt; c(pool);   if (!c-\u0026gt;connect(3000)) {  LOG \u0026lt;\u0026lt; \u0026#34;connect failed: \u0026#34;\u0026lt;\u0026lt; c-\u0026gt;strerror();  return;  }   char buf[8] = {0 };   while (true) {  LOG \u0026lt;\u0026lt; \u0026#34;client send ping\u0026#34;;  int r = c-\u0026gt;send(\u0026#34;ping\u0026#34;, 4);  if (r \u0026lt;= 0) {  LOG \u0026lt;\u0026lt; \u0026#34;client send error: \u0026#34;\u0026lt;\u0026lt; c-\u0026gt;strerror();  break;  }   r = c-\u0026gt;recv(buf, 8);  if (r \u0026lt; 0) {  LOG \u0026lt;\u0026lt; \u0026#34;client recv error: \u0026#34;\u0026lt;\u0026lt; c-\u0026gt;strerror();  break;  } else if (r == 0) {  LOG \u0026lt;\u0026lt; \u0026#34;server close the connection\u0026#34;;  break;  } else {  LOG \u0026lt;\u0026lt; \u0026#34;client recv \u0026#34;\u0026lt;\u0026lt; fastring(buf, r) \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;  co::sleep(3000);  }  } }  proto.reset(new tcp::Client(\u0026#34;127.0.0.1\u0026#34;, 7788, use_ssl)); for (int i = 0; i \u0026lt;8; ++i) {  go(client_fun); }  In the above example, we use co::Pool to cache client connections, and different coroutines can share connections in co::Pool. co::PoolGuard automatically pop an idle connection from co::Pool during construction, and automatically puts the connection back into co::Pool during destruction.  "},{"id":18,"href":"/en/co/net/http/","title":"HTTP","section":"Network Programming","content":"include: co/so/http.h.\n#http::Client\rhttp::Client is a coroutine-based http client, which is implemented based on libcurl.\n#Client::Client\rexplicit Client(const char* serv_url);  Constructor, the parameter serv_url is the url address of the server, and its form is protocol://host:port, the following server urls are all ok:  \u0026ldquo;github.com\u0026rdquo; \u0026ldquo;https://github.com\u0026rdquo; \u0026ldquo;http://127.0.0.1:7788\u0026rdquo; \u0026ldquo;http://[::1]:8888\u0026rdquo;   Like the tcp::Client, connection is not established in the constructor.  #Client::~Client\rClient::~Client();  Destructor, close the connection, and release libcurl related resources.  #Client::add_header\rvoid add_header(const char* key, const char* val); void add_header(const char* key, int val);  Add a HTTP header. Users can use this method to add headers before performing HTTP requests, and the added headers will be present in all subsequent requests. In the second version, the parameter val is an integer, which is automatically converted into a string internally.  #Client::body\rconst char* body() const;  Get the response body of the current HTTP request. It returns a pointer to the body data, and it is not null-terminated, the user needs to use the body_size() method to get its length.  #Client::body_size\rsize_t body_size() const;  Returns length of the response body of the current HTTP request.  #Client::close\rvoid close();  Close the HTTP connection, must be called in the coroutine. Once this method is called, the http::Client object can no longer be used.  #Client::del\rvoid del(const char* url, const char* s, size_t n); void del(const char* url, const char* s); void del(const char* url);  HTTP DELETE request, must be called in the coroutine. The parameter url must be a string beginning with '/'. The first two versions are suitable for DELETE requests with a body, and parameter s is a pointer to the body data. The third version is for DELETE requests without body.  #Client::easy_handle\rvoid* easy_handle() const;  Return the easy handle of libcurl.  #Client::get\rvoid get(const char* url);  HTTP GET request, must be called in the coroutine. The parameter url must be a string beginning with '/'.  #Client::head\rvoid head(const char* url);  HTTP HEAD request, must be called in the coroutine. The parameter url must be a string beginning with '/'.  #Client::header\rconst char* header(const char* key); const char* header() const;   The first version gets value of a HTTP header. If the header does not exist, an empty string is returned.\n  The second version gets the entire HTTP header part.\n  Example\n  http::Client c(\u0026#34;xx.com\u0026#34;); c.get(\u0026#34;/\u0026#34;); auto s = c.header(\u0026#34;Content-Length\u0026#34;); #Client::perform\rvoid perform();   Perform a HTTP request, get, post and other methods are actually implemented based on this method.\n  Users generally don\u0026rsquo;t need to call this method. Only when the get, post and other methods provided by http::Client can\u0026rsquo;t meet their needs, should they consider using this method to customize HTTP requests.\n  Example\n  void Client::post(const char* url, const char* data, size_t size) {  curl_easy_setopt(_ctx-\u0026gt;easy, CURLOPT_POST, 1L);  curl_easy_setopt(_ctx-\u0026gt;easy, CURLOPT_URL, make_url(url));  curl_easy_setopt(_ctx-\u0026gt;easy, CURLOPT_POSTFIELDS, data);  curl_easy_setopt(_ctx-\u0026gt;easy, CURLOPT_POSTFIELDSIZE, (long)size);  this-\u0026gt;perform(); } #Client::post\rvoid post(const char* url, const char* s, size_t n); void post(const char* url, const char* s);  HTTP POST request, must be called in the coroutine. The parameter url must be a string beginning with '/'.  #Client::put\rvoid put(const char* url, const char* s, size_t n); void put(const char* url, const char* s);  HTTP PUT request, must be called in the coroutine. The parameter url must be a string beginning with '/'.  #Client::remove_header\rvoid remove_header(const char* key);  The headers added by add_header() method will apply to all subsequent HTTP requests. If the user does not want a header to appear in the subsequent request, this method can be used to delete this header.  #Client::response_code\rint response_code() const;  Get the response code of the current HTTP request. Normally, the return value is a value between 100 and 511. If the HTTP request is not sent due to network error or other reasons, or no response from the server was received within the timeout period, this method returns 0.  #Client::strerror\rconst char* strerror() const;  Get the error information of the current HTTP request.  #Code example\rvoid f() {  http::Client c(\u0026#34;https://github.com\u0026#34;);  int r;   c.get(\u0026#34;/\u0026#34;);  r = c.response_code();  LOG \u0026lt;\u0026lt; \u0026#34;response code: \u0026#34;\u0026lt;\u0026lt; r;  LOG_IF(r == 0) \u0026lt;\u0026lt; \u0026#34;error: \u0026#34;\u0026lt;\u0026lt; c.strerror();  LOG \u0026lt;\u0026lt; \u0026#34;body size: \u0026#34;\u0026lt;\u0026lt; c.body_size();  LOG \u0026lt;\u0026lt; c.header();   c.get(\u0026#34;/idealvin/co\u0026#34;);  LOG \u0026lt;\u0026lt; \u0026#34;body size: \u0026#34;\u0026lt;\u0026lt; c.body_size();  LOG \u0026lt;\u0026lt; \u0026#34;Content-Length: \u0026#34;\u0026lt;\u0026lt; c.header(\u0026#34;Content-Length\u0026#34;);  LOG \u0026lt;\u0026lt; c.header();   c.close(); }  go(f); #http::Req\rhttp::Req is an encapsulation of HTTP request, it is used in http::Server.\n#Req::Req\rReq() = default;  Default constructor.  #Req::body\rconst char* body() const;  Get the body data in the HTTP request. It returns a pointer, not null-terminated. The user needs to call the body_size() method to get its length.  #Req::body_size\rsize_t body_size() const;  Returns the length of the HTTP request body.  #Req::clear\rvoid clear();  Clear the http::Req object, the user can continue to use it after it is cleared.  #Req::header\rconst char* header(const char* key) const;  Get the value of the HTTP header. If the header does not exist, an empty string is returned.  #Req::is_method_xxx\rbool is_method_get() const; bool is_method_head() const; bool is_method_post() const; bool is_method_put() const; bool is_method_delete() const; bool is_method_options() const;  Determine the method type of the HTTP request.  #Req::url\rconst fastring\u0026amp; url() const;  Returns a reference to the url in the HTTP request. This value is part of the start line of the HTTP request.  #Req::version\rVersion version() const;  Returns the HTTP version in the HTTP request. The return value is one of http::kHTTP10 or http::kHTTP11. Currently, HTTP/2.0 is not supported.  #http::Res\rhttp::Res class is the encapsulation of HTTP response, it is used in http::Server.\n#Res::Res\rRes();  Default constructor.  #Res::add_header\rvoid add_header(const char* key, const char* val);  Add a HTTP header.  #Res::body_size\rsize_t body_size() const  Returns the length of the HTTP response body.  #Res::clear\rvoid clear();  Clear the http::Res object, the user can continue to use it after it is cleared.  #Res::set_body\rvoid set_body(const void* s, size_t n); void set_body(const char* s);  Set the body part of the HTTP response. The parameter s is the body data, and the parameter n is the length of s. In the second version, s ends with '\\0'.  #Res::set_status\rvoid set_status(int status);  Set the HTTP response code, this value is generally between 100 and 511.  #Res::set_version\rvoid set_version(Version v);  Set the HTTP version in the HTTP response, HTTP/1.1 is used by default. Users generally do not need to call this method.  #Res::str\rfastring str() const;  Convert the HTTP response into a string, which can be sent to the Internet.  #http::Server\rhttp::Server is a coroutine-based HTTP server. It supports HTTPS. To use HTTPS, you need to install openssl first.\n#Server::Server\rServer();  The default constructor, users don\u0026rsquo;t need to care.  #Server::on_req\rvoid on_req(std::function\u0026lt;void(const Req\u0026amp;, Res\u0026amp;)\u0026gt;\u0026amp;\u0026amp; f); template\u0026lt;typename T\u0026gt; void on_req(void (T::*f)(const Req\u0026amp;, Res\u0026amp;), T* o);  Set a callback for processing a HTTP request. In the second version, the parameter f is a method in class T, and the parameter o is a pointer to type T. When the server receives an HTTP request, it will call the callback set by this method to process the request.  #Server::start\rvoid start(const char* ip=\u0026#34;0.0.0.0\u0026#34;, int port=80); void start(const char* ip, int port, const char* key, const char* ca);  Start the HTTP server, this method will not block the current thread. The parameter ip is the server ip, which can be an IPv4 or IPv6 address, and the parameter port is the server port. The parameter key is path of a **PEM **file which stores the SSL private key, and the parameter ca is path of a PEM file which stores the SSL certificate. If key or ca is NULL or empty string, SSL will be disabled.  #Server::exit\rvoid exit();  Added since v2.0.2. Exit the HTTP server, close the listening socket, and no longer receive new connections. This method will not close the connections that has been established before.  #Code example\rhttp::Server s  s.on_req(  [](const http::Req\u0026amp; req, http::Res\u0026amp; res) {  if (req.is_method_get()) {  if (req.url() == \u0026#34;/hello\u0026#34;) {  res.set_status(200);  res.set_body(\u0026#34;hello world\u0026#34;);  } else {  res.set_status(404);  }  } else {  res.set_status(405);  }  } );  // start as a http server s.start(\u0026#34;0.0.0.0\u0026#34;, 7777);  // start as a https server s.start(\u0026#34;0.0.0.0\u0026#34;, 7777, \u0026#34;privkey.pem\u0026#34;, \u0026#34;certificate.pem\u0026#34;); There is a simple http::Server demo in co/test, the user can build and run it like this:\nxmake -b http_serv xmake r http_serv After starting the http server, you can enter 127.0.0.1/hello in the address bar of the browser to see the result.\n#so::easy\rvoid easy(const char* root_dir=\u0026#34;.\u0026#34;, const char* ip=\u0026#34;0.0.0.0\u0026#34;, int port=80); void easy(const char* root_dir, const char* ip, int port, const char* key, const char* ca);   Start a static web server, the parameter root_dir is the root directory of the web server.\n  The parameter ip can be an IPv4 or IPv6 address.\n  The second version supports HTTPS, the parameter key is the SSL private key, the parameter ca is the SSL certificate, and both key and ca are files in pem format.\n  When key or ca is NULL or an empty string, HTTPS is not used.\n  This method will block the current thread.\n  Example\n  #include \u0026#34;co/flag.h\u0026#34;#include \u0026#34;co/log.h\u0026#34;#include \u0026#34;co/so.h\u0026#34; DEF_string(d, \u0026#34;.\u0026#34;, \u0026#34;root dir\u0026#34;); // root dir of web server  int main(int argc, char** argv) {  flag::init(argc, argv);  log::init();   so::easy(FLG_d.c_str()); // mum never have to worry again   return 0; } #Configuration items\r#http_conn_timeout\rDEF_uint32(http_conn_timeout, 3000, \u0026#34;#2 connect timeout in ms for http client\u0026#34;);  Connect timeout in milliseconds for http::Client.  #http_timeout\rDEF_uint32(http_timeout, 3000, \u0026#34;#2 send or recv timeout in ms for http client\u0026#34;);  Receive and send timeout (libcurl does not distinguish between receive and send timeout) in milliseconds for http::Client.  #http_recv_timeout\rDEF_uint32(http_recv_timeout, 3000, \u0026#34;#2 recv timeout in ms for http server\u0026#34;);  Recv timeout in milliseconds for http::Server.  #http_send_timeout\rDEF_uint32(http_send_timeout, 3000, \u0026#34;#2 send timeout in ms for http server\u0026#34;);  Send timeout in milliseconds for http::Server.  #http_conn_idle_sec\rDEF_uint32(http_conn_idle_sec, 180, \u0026#34;#2 http server may close the con...\u0026#34;);  Timeout in seconds for http::Server to keep an idle connection. If the server does not receive data from the client within this time, it may close the connection.  #http_log\rDEF_bool(http_log, true, \u0026#34;#2 enable http server log if true\u0026#34;);  For http::Server, whether to print logs, the default is true. The log in http::Server will print the header part of HTTP request and response.  #http_max_idle_conn\rDEF_uint32(http_max_idle_conn, 128, \u0026#34;#2 max idle connections for http server\u0026#34;);  For http::Server, maximum number of idle connections. When this number is exceeded, some idle connections will be closed.  #http_max_body_size\rDEF_uint32(http_max_body_size, 8 \u0026lt;\u0026lt; 20, \u0026#34;#2 max size of http body, default: 8M\u0026#34;);  The maximum body length supported by http::Server, the default is 8M.  #http_max_header_size\rDEF_uint32(http_max_header_size, 4096, \u0026#34;#2 max size of http header\u0026#34;);  The maximum header (the entire HTTP header) length supported by http::Server, the default is 4k.  "},{"id":19,"href":"/en/co/net/rpc/","title":"RPC","section":"Network Programming","content":"include: co/so/rpc.h.\nco/rpc is a RPC framework similar to grpc and thrift, it uses JSON format for transmission data, which is different from binary protocols such as protobuf, thrift, etc.\n#rpc::Service\rrpc::Service is an interface class, which represents a service. A RPC server can contain multiple services.\n#Service::name\rvirtual const char* name() const = 0;  Returns the service name, which contains the package name, such as \u0026ldquo;xx.yy.HelloWorld\u0026rdquo;. In the RPC request, a **\u0026ldquo;service\u0026rdquo; ** field must be carried, and its value is the service name.  #Service::process\rvirtual void process(const Json\u0026amp; req, Json\u0026amp; res) = 0;  This method is used to process a RPC request, and the result is filled in res. When the server receives an RPC request, it finds the corresponding service according to the \u0026ldquo;service\u0026rdquo; field in req, and then calls the process() method to process the request.  #rpc::Server\rrpc::Server is implemented based on tcp::Server, which supports SSL and user name and password authentication. Test results a few years ago showed that a single-threaded QPS can reach 120k+.\n#Server::Server\rServer();  The default constructor, users do not need to care.  #Server::add_service\rvoid add_service(Service* s);  Add a service, the parameter s must be dynamically created with operator new. The user can call this method multiple times to add multiple services, and different services must have different names.  #Server::add_userpass\rvoid add_userpass(const char* user, const char* pass); void add_userpass(const char* s);   The first version adds a pair of username and password. The user can call this method multiple times to add multiple user names and passwords.\n  In the second version, s is a JSON string containing usernames and passwords, and its value is like {\u0026quot;user1\u0026quot;:\u0026quot;pass1\u0026quot;, \u0026quot;user2\u0026quot;:\u0026quot;pass2\u0026quot;}. Users can call this method to add multiple pairs of usernames and passwords at once.\n  rpc::Server does not store the password plaintext in memory, but saves the md5 of the password.\n  Example\n  DEF_string(password, \u0026#34;\u0026#34;, \u0026#34;password\u0026#34;); DEF_string(userpass, \u0026#34;\u0026#34;, \u0026#34;usernames and passwords\u0026#34;);  rpc::Server s; s.add_userpass(\u0026#34;alice\u0026#34;, FLG_password.c_str()); FLG_password.safe_clear();  s.add_userpass(FLG_userpass.c_str()); FLG_userpass.safe_clear();  The above example, defines a flag to save the password. The default value is empty. The password must be passed in from the command line or configuration file. After calling the add_userpass() method, immediately call the safe_clear() method to clear the password content.  #Server::start\rvoid start(const char* ip, int port, const char* key=NULL, const char* ca=NULL);  Start the RPC server, this method will not block the current thread. The parameter ip is the server ip, which can be an IPv4 or IPv6 address, and the parameter port is the server port. The parameter key is path of a **PEM **file which stores the SSL private key, and the parameter ca is path of a PEM file which stores the SSL certificate. They are NULL by default, and SSL is disabled.  #Server::exit\rvoid exit();  Added since v2.0.2. Exit the RPC server, close the listening socket, and no longer receive new connections. This method will not close the connections that has been established before.  #RPC server example\r#Define a proto file\r// hello_world.proto  package xx // namespace xx  service HelloWorld {  hello,  world, }   The above is a simple proto file, # Or // are for comments.\n  package xx specifies the package name. In C++, it means that the code is generated into a namespace. You can use package xx.yy.zz to generate nested namespaces.\n  service HelloWorld defines a service class that inherits from rpc::Service, and its name is \u0026ldquo;xx.HelloWorld\u0026rdquo;. The service class provides two RPC methods, hello and world.\n  **A proto file can define only one service. **In the proto file, the contents after the service definition will be ignored. Generally, you can add the JSON parameter of the RPC methods after the service definition, as shown below:\n  package xx // namespace xx  // class HelloWorld : public rpc::Service service HelloWorld {  hello, // void HelloWorld::hello(const Json\u0026amp; req, Json\u0026amp; res);  world, // void HelloWorld::world(const Json\u0026amp; req, Json\u0026amp; res); }  // All the following are ignored by the code generator. // param hello.req {  \u0026#34;service\u0026#34;: \u0026#34;xx.HelloWorld\u0026#34;,  \u0026#34;method\u0026#34;: \u0026#34;hello\u0026#34; }  hello.res {  \u0026#34;err\u0026#34;: 200,  \u0026#34;errmsg\u0026#34;: \u0026#34;ok\u0026#34; }  world.req {  \u0026#34;service\u0026#34;: \u0026#34;xx.HelloWorld\u0026#34;,  \u0026#34;method\u0026#34;: \u0026#34;world\u0026#34; }  world.res {  \u0026#34;err\u0026#34;: 200,  \u0026#34;errmsg\u0026#34;: \u0026#34;ok\u0026#34; } #Generate RPC framework code\rgen is the RPC code generator provided by co, which can be used to generate code for RPC service and client.\nxmake -b gen # build gen cp gen /usr/local/bin # put gen in the /usr/local/bin directory gen hello_world.proto # Generate code gen *.proto # Batch generation The file generated for hello_world.proto is hello_world.h, and code of the service class is as follows:\n// Autogenerated. DO NOT EDIT. All changes will be undone.  #pragma once  #include \u0026#34;co/so/rpc.h\u0026#34; namespace xx {  class HelloWorld : public rpc::Service {  public:  typedef void (HelloWorld::*Fun)(const Json\u0026amp;, Json\u0026amp;);   HelloWorld() : _name(\u0026#34;xx.HelloWorld\u0026#34;) {  _methods[hash64(\u0026#34;hello\u0026#34;)] = \u0026amp;HelloWorld::hello;  _methods[hash64(\u0026#34;world\u0026#34;)] = \u0026amp;HelloWorld::world;  }   virtual ~HelloWorld() {}   virtual const char* name() const {  return _name.c_str();  }   virtual void process(const Json\u0026amp; req, Json\u0026amp; res) {  json::Value method = req[\u0026#34;method\u0026#34;];  if (!method.is_string()) {  res.add_member(\u0026#34;err\u0026#34;, 400);  res.add_member(\u0026#34;errmsg\u0026#34;, \u0026#34;req has no method\u0026#34;);  return;  }   auto it = _methods.find(hash64(method.get_string(), method.string_size()));  if (it == _methods.end()) {  res.add_member(\u0026#34;err\u0026#34;, 404);  res.add_member(\u0026#34;errmsg\u0026#34;, \u0026#34;method not found\u0026#34;);  return;  }   (this-\u0026gt;*(it-\u0026gt;second))(req, res);  }   virtual void hello(const Json\u0026amp; req, Json\u0026amp; res) = 0;   virtual void world(const Json\u0026amp; req, Json\u0026amp; res) = 0;   private:  std::unordered_map\u0026lt;uint64, Fun\u0026gt; _methods;  fastring _name; };  } // xx  As you can see, the HelloWorld class inherits from rpc::Service, and it has already implemented the name() and process() methods in rpc::Service. In the process() method, the corresponding RPC method will be called according to the \u0026ldquo;method\u0026rdquo; field in req. Users only need to inherit the HelloWorld class and implement the hello and world methods.  #Implement the RPC service\r#include \u0026#34;hello_world.h\u0026#34; namespace xx {  class HelloWorldImpl: public HelloWorld {  public:  HelloWorldImpl() = default;  virtual ~HelloWorldImpl() = default;   virtual void hello(const Json\u0026amp; req, Json\u0026amp; res) {  res.add_member(\u0026#34;method\u0026#34;, \u0026#34;hello\u0026#34;);  res.add_member(\u0026#34;err\u0026#34;, 200);  res.add_member(\u0026#34;errmsg\u0026#34;, \u0026#34;ok\u0026#34;);  }   virtual void world(const Json\u0026amp; req, Json\u0026amp; res) {  res.add_member(\u0026#34;method\u0026#34;, \u0026#34;world\u0026#34;);  res.add_member(\u0026#34;err\u0026#34;, 200);  res.add_member(\u0026#34;errmsg\u0026#34;, \u0026#34;ok\u0026#34;);  } };  } // xx  The above is just a very simple example. In actual applications, it is generally necessary to perform corresponding business processing according to the parameters in req, and then fill in res.  #Start RPC server\rrpc::Server s; s.add_userpass(\u0026#34;alice\u0026#34;, \u0026#34;nice\u0026#34;); s.add_service(new xx::HelloWorldImpl);  // without ssl s.start(\u0026#34;127.0.0.1\u0026#34;, 7788);  // with ssl s.start(\u0026#34;127.0.0.1\u0026#34;, 7788, \u0026#34;privkey.pem\u0026#34;, \u0026#34;certificate.pem\u0026#34;);  Line 2 calls add_userpass() to add a pair of username and password, which is optional. Line 3 calls add_service() to add the implementation of the HelloWorld service. Lines 6 and 9 start the RPC server, and line 9 adds two more parameters to specify SSL transmission.  #rpc::Client\r#Client::Client\rClient(const char* ip, int port, bool use_ssl=false);  Constructor. The parameter ip is the ip of the server, which can be a domain name, IPv4 or IPv6 address; the parameter port is the server port; the parameter use_ssl indicates whether to enable SSL transmission, the default is false, and SSL is not enabled. When rpc::Client was constructed, no connection was established.  #Client::~Client\rClient::~Client();  Destructor, close the internal connection.  #Client::call\rvoid call(const Json\u0026amp; req, Json\u0026amp; res);  Perform a RPC request, it must be called in the coroutine. The parameter req must contain at least two fields, \u0026ldquo;service\u0026rdquo; and \u0026ldquo;method\u0026rdquo;, which are used to call the method in the specified service. The parameter res is the response result of the RPC request. If the RPC request is not sent, or no response from the server is received, res will not be filled. This method checks the connection status before sending the RPC request, and establishes the connection first if it is not connected.  #Client::close\rvoid close();  Close the connection, it is safe to call this function multiple times.  #Client::ping\rvoid ping();  Send a heartbeat to rpc::Server.  #Client::set_userpass\rvoid set_userpass(const char* user, const char* pass);  Set a pair of username and password. This method only needs to be called once, if it is called multiple times, the later value will overwrite the previous value. This method must be called before initiating an RPC request.  #RPC client example\r#Use the rpc::Client\rDEF_bool(use_ssl, false, \u0026#34;use ssl if true\u0026#34;); DEF_string(password, \u0026#34;\u0026#34;, \u0026#34;password\u0026#34;); DEF_int32(n, 3, \u0026#34;request num\u0026#34;);  void client_fun() {  rpc::Client c(\u0026#34;127.0.0.1\u0026#34;, 7788, FLG_use_ssl);  c.set_userpass(\u0026#34;alice\u0026#34;, FLG_password.c_str());  FLG_password.safe_clear(); // clear password in the memory   for (int i = 0; i \u0026lt; FLG_n; ++i) {  Json req, res;  req.add_member(\u0026#34;service\u0026#34;, \u0026#34;xx.HelloWorld\u0026#34;);  req.add_member(\u0026#34;method\u0026#34;, \u0026#34;hello\u0026#34;);  c.call(req, res);  co::sleep(1000);  }   c.close(); }  go(client_fun);  In RPC request, \u0026ldquo;service\u0026rdquo; and \u0026ldquo;method\u0026rdquo; are required fields. To use rpc::Client, users need to manually set the \u0026ldquo;service\u0026rdquo; and \u0026ldquo;method\u0026rdquo; fields in the request.  #Use the automatically generated HelloWorldClient\rThe code generated by hello_world.proto above also contains a client code:\nclass HelloWorldClient {  public:  HelloWorldClient(const char* ip, int port, bool use_ssl=false)  : _rpc_cli(ip, port, use_ssl), _serv_name(\u0026#34;xx.HelloWorld\u0026#34;) {  }   HelloWorldClient(const HelloWorldClient\u0026amp; c)  : _rpc_cli(c._rpc_cli), _serv_name(c._serv_name) {  }   ~HelloWorldClient() {}   void set_userpass(const char* user, const char* pass) {  _rpc_cli.set_userpass(user, pass);  }   void close() {  _rpc_cli.close();  }   Json make_req_hello() {  Json req;  req.add_member(\u0026#34;service\u0026#34;, _serv_name);  req.add_member(\u0026#34;method\u0026#34;, \u0026#34;hello\u0026#34;);  return req;  }   Json make_req_world() {  Json req;  req.add_member(\u0026#34;service\u0026#34;, _serv_name);  req.add_member(\u0026#34;method\u0026#34;, \u0026#34;world\u0026#34;);  return req;  }   Json perform(const Json\u0026amp; req) {  Json res;  _rpc_cli.call(req, res);  return res;  }   void ping() {  _rpc_cli.ping();  }   private:  rpc::Client _rpc_cli;  fastring _serv_name; };  HelloWorldClient just simply wraps rpc::Client, which is a little more convenient than rpc::Client, and there is no need to manually set the \u0026ldquo;service\u0026rdquo; and \u0026ldquo;method\u0026rdquo; fields.  #include \u0026#34;hello_world.h\u0026#34; std::unique_ptr\u0026lt;xx:HelloWorldClient\u0026gt; proto;  co::Pool p(  []() { return (void*) new xx::HelloWorldClient(*proto); },  [](void* p) { delete (xx::HelloWorldClient*) p; } );  void client_fun() {  co::PoolGuard\u0026lt;xx::HelloWorldClient\u0026gt; c(p);   for (int i = 0; i \u0026lt; 10; ++i) {  Json req = c-\u0026gt;make_req_hello();  req.add_member(\u0026#34;xx\u0026#34;, \u0026#34;123\u0026#34;);  Json res = c-\u0026gt;perform(req);  co::sleep(1000);  } }  proto.reset(new xx::HelloWorldClient(\u0026#34;127.0.0.1\u0026#34;, 7788)); proto-\u0026gt;set_userpass(\u0026#34;alice\u0026#34;, \u0026#34;nice\u0026#34;);  for (int i = 0; i \u0026lt; 8; ++i) {  go(client_fun); }  In the above example, co::Pool is used to store the clients, and multiple coroutines can share these clients. co::PoolGuard automatically pops an idle client from co::Pool when it is created, and automatically puts the client back into co::Pool when it is destructed. The ccb of co::Pool uses copy construction to copy a client from proto, so that ip, port, username and password need to be set only once in the proto client. The make_req_xxx() method provided by HelloWorldClient returns a Json object filled with the \u0026ldquo;service\u0026rdquo; and \u0026ldquo;method\u0026rdquo; fields. The perform() method provided by HelloWorldClient performs the RPC request and returns the RPC response result.  #Configuration items\r#rpc_conn_idle_sec\rDEF_int32(rpc_conn_idle_sec, 180, \u0026#34;#2 connection may be closed if no data...\u0026#34;);  Timeout in **seconds **for idle connections in rpc::Server. If a connection does not receive any data within this time, the server may close the connection.  #rpc_conn_timeout\rDEF_int32(rpc_conn_timeout, 3000, \u0026#34;#2 connect timeout in ms\u0026#34;);  Connect timeout in milliseconds for rpc::Client.  #rpc_log\rDEF_bool(rpc_log, true, \u0026#34;#2 enable rpc log if true\u0026#34;);  Whether to print RPC logs, the default is true, rpc::Server and rpc::Client will print RPC requests and responses.  #rpc_max_idle_conn\rDEF_int32(rpc_max_idle_conn, 128, \u0026#34;#2 max idle connections\u0026#34;);  Maximum number of idle connections for rpc::Server. The default is 128. When this number is exceeded, the server will close some idle connections.  #rpc_max_msg_size\rDEF_int32(rpc_max_msg_size, 8 \u0026lt;\u0026lt; 20, \u0026#34;#2 max size of rpc message, default: 8M\u0026#34;);  The maximum length of RPC messages, the default is 8M.  #rpc_recv_timeout\rDEF_int32(rpc_recv_timeout, 1024, \u0026#34;#2 recv timeout in ms\u0026#34;);  RPC recv timeout in milliseconds.  #rpc_send_timeout\rDEF_int32(rpc_send_timeout, 1024, \u0026#34;#2 send timeout in ms\u0026#34;);  RPC send timeout in milliseconds.  "},{"id":20,"href":"/en/co/tasked/","title":"Timed task scheduler","section":"Documents for CO","content":"include: co/tasked.h.\n#Tasked\rThe Tasked class is a simple timed task scheduler. All tasks are scheduled internally by a single thread, but tasks can be added from any thread. When a task is blocked, it will affect all subsequent tasks. Therefore, it is not recommended to use Tasked to schedule tasks that may block for a long time.\n#Tasked::Tasked\rTasked(); Tasked(Tasked\u0026amp;\u0026amp; t);  The first version is the default constructor. When the object is created, the scheduling thread will start. The second version is the move constructor.  #Tasked::~Tasked\r~Tasked();  Destructor, stop the task scheduling thread.  #Tasked::F\rtypedef std::function\u0026lt;void()\u0026gt; F;  The task type.  #Tasked::run_at\rvoid run_at(F\u0026amp;\u0026amp; f, int hour, int minute=0, int second=0); void run_at(const F\u0026amp; f, int hour, int minute=0, int second=0);  Add a task to run at the specified time, f will run once at time of hour:minute:second. hour must be an integer between 0-23, minute and second must be an integer between 0-59, and the default is 0.  #Tasked::run_daily\rvoid run_daily(F\u0026amp;\u0026amp; f, int hour=0, int minute=0, int second=0); void run_daily(const F\u0026amp; f, int hour=0, int minute=0, int second=0);  Add a periodic task that runs at a specified time every day, f will run once every day at the time of hour:minute:second. hour must be an integer between 0-23, the default is 0, minute and second are integers between 0-59, and the default is 0.  #Tasked::run_every\rvoid run_every(F\u0026amp;\u0026amp; f, int n); void run_every(const F\u0026amp; f, int n);  Add a periodic task that run every n seconds.  #Tasked::run_in\rvoid run_in(F\u0026amp;\u0026amp; f, int n); void run_in(const F\u0026amp; f, int n);  Add a task that runs once in n seconds.  #Tasked::stop\rvoid stop();  Stop the task scheduling thread, this method will be automatically called in the destructor. It is safe to call this method multiple times.  #Code example\rTasked s; // create and start the scheduler s.run_in(f, 3); // run f 3 seconds later s.run_every(std::bind(f, 0), 3); // run f every 3 seconds s.run_at(f, 23); // run f once at 23:00:00 s.run_daily(f); // run f at 00:00:00 every day s.run_daily(f, 23); // run f at 23:00:00 every day s.run_daily(f, 23, 30); // run f at 23:30:00 every day s.stop(); // stop the scheduler "},{"id":21,"href":"/en/co/random/","title":"Random number","section":"Documents for CO","content":"include: co/random.h.\n#Random\rThe Random class is a very fast pseudo-random number generator, which can generate integers between 1 and 2G-2 continuously and without repetition.\n#Random::Random\rRandom(); explicit Random(uint32_t seed);  The default constructor uses 1 as the seed number, and the second constructor uses the parameter seed as the seed number.  #Random::next\ruint32_t next();   Returns the next pseudo-random number, not thread safe. Once the seed number is determined, the random sequence generated by calling next() is completely determined.\n  Example\n  Random r(7); int n = r.next(); "},{"id":22,"href":"/en/co/lrumap/","title":"LruMap","section":"Documents for CO","content":"include: co/lru_map.h.\n#LruMap\rtemplate \u0026lt;typename K, typename V\u0026gt; class LruMap; LruMap is a map implemented based on the LRU (least recently used) strategy. When the number of elements in the map reaches the upper limit, the least recently used data will be replaced first. It is implemented based on std::list and std::unordered_map, and the internal elements are unordered.\n#LruMap::LruMap\rLruMap(); explicit LruMap(size_t capacity);  The default constructor uses 1024 as the maximum capacity. The second constructor takes the parameter capacity as the maximum capacity.  #LruMap::begin\riterator begin() const;  Returns an iterator pointing to the first element. When LruMap is empty, the return value is equal to LruMap::end().  #LruMap::clear\rvoid clear();  This method clears the elements in LruMap, size() will become 0, and the capacity will remain unchanged.  #LruMap::empty\rbool empty() const;  This method determines whether LruMap is empty.  #LruMap::end\riterator end() const;  Returns an iterator pointing to the next position of the last element, it does not point to any element itself. When LruMap is empty, begin() and end() are equal.  #LruMap::erase\rvoid erase(iterator it); void erase(const key_type\u0026amp; key);  Erase an element through iterator or key.  #LruMap::find\riterator find(const key_type\u0026amp; key)  This method finds an element by key, and returns an iterator refer to the element if it is found, otherwise the return value is equal to end().  #LruMap::insert\rtemplate \u0026lt;typename Key, typename Val\u0026gt; void insert(Key\u0026amp;\u0026amp; key, Val\u0026amp;\u0026amp; value);  Insert an element, only when the key does not exist, it will insert a new element. If the key already exists, no operation will be performed. During the insert operation, if the number of elements has reached the maximum capacity, the least recently accessed element will be removed.  #LruMap::size\rsize_t size() const;  Returns the number of elements in LruMap.  #LruMap::swap\rvoid swap(LruMap\u0026amp; x) noexcept; void swap(LruMap\u0026amp;\u0026amp; x) noexcept;  Exchange the contents of two LruMaps. This operation only exchanges internal pointers, size, and capacity.  #Code example\rLruMap\u0026lt;int, int\u0026gt; m(128); // capacity: 128  auto it = m.find(1); if (it == m.end()) {  m.insert(1, 23); } else {  it-\u0026gt;second = 23; }  m.erase(it); // erase by iterator m.erase(it-\u0026gt;first); // erase by key m.clear(); // clear the map "},{"id":23,"href":"/en/co/hash/","title":"Hash","section":"Documents for CO","content":"include: co/hash.h.\n#Hash\r#hash32\ruint32 hash32(const char* s); uint32 hash32(const fastring\u0026amp; s) uint32 hash32(const std::string\u0026amp; s); uint32 hash32(const void* s, size_t n);  This function returns a 32-bit murmur hash value. When s is a pointer, it is generally required to be byte-aligned by sizeof(void*).  #hash64\ruint64 hash64(const void* s, size_t n); uint64 hash64(const char* s); uint64 hash64(const fastring\u0026amp; s); uint64 hash64(const std::string\u0026amp; s);  This function returns a 64-bit murmur hash value. When s is a pointer, it is generally required to be 8-byte aligned.  #murmur_hash\rsize_t murmur_hash(const void* s, size_t n);  This function returns a hash value of size_t type. This value is 64-bit on 64-bit platform and 32-bit on 32-bit platform. The parameter s is generally required to be sizeof(void*) byte-aligned.  #md5sum\rfastring md5sum(const void* s, size_t n); fastring md5sum(const char* s); fastring md5sum(const fastring\u0026amp; s); fastring md5sum(const std::string\u0026amp; s);  This function calculates the md5 value of a string and returns a 32-byte string containing only hexadecimal characters.  #crc16\ruint16_t crc16(const void* s, size_t n); uint16_t crc16(const char* s); uint16_t crc16(const fastring\u0026amp; s); uint16_t crc16(const std::string\u0026amp; s);  This function calculates the crc16 value of a string. The implementation is taken from redis and will be used when implementing the redis cluster client.  #base64_encode\rfastring base64_encode(const void* s, size_t n); fastring base64_encode(const char* s); fastring base64_encode(const fastring\u0026amp; s); fastring base64_encode(const std::string\u0026amp; s);  base64 encoding, \\r\\n is not added in the implementation.  #base64_decode\rfastring base64_decode(const void* s, size_t n); fastring base64_decode(const char* s); fastring base64_decode(const fastring\u0026amp; s); fastring base64_decode(const std::string\u0026amp; s);  base64 decoding, if the input is not reasonable base64-encoded data, the decoding will fail and an empty string will be returned.  #url_encode\rfastring url_encode(const void* s, size_t n); fastring url_encode(const char* s); fastring url_encode(const fastring\u0026amp; s); fastring url_encode(const std::string\u0026amp; s);  url encoding, reserved characters !()*#$\u0026amp;'+,/:;=?@[] and a-z A-Z 0-9 -_.~ will not be encoded, all other characters will be encoded.  #url_decode\rfastring url_decode(const void* s, size_t n); fastring url_decode(const char* s); fastring url_decode(const fastring\u0026amp; s); fastring url_decode(const std::string\u0026amp; s);  url decoding, if the input is not a reasonably encoded url, the decoding will fail and an empty string will be returned.  "},{"id":24,"href":"/en/co/path/","title":"Path","section":"Documents for CO","content":"include: co/path.h.\n#path\rco/path is ported from golang, the path separator must be '/' .\n#path::clean()\rfastring clean(const fastring\u0026amp; s);   Return the shortest equivalent form of the path, the consecutive separators in the path will be removed.\n  Example\n  path::clean(\u0026#34;./x//y/\u0026#34;); // return \u0026#34;x/y\u0026#34; path::clean(\u0026#34;./x/..\u0026#34;); // return \u0026#34;.\u0026#34; path::clean(\u0026#34;./x/../..\u0026#34;); // return \u0026#34;..\u0026#34; #path::join()\rfastring join(const fastring\u0026amp; s, const fastring\u0026amp; t); template \u0026lt;typename ...S\u0026gt; fastring join(const S\u0026amp;... s);   The first version concatenates two fastrings into a complete path.\n  The second version concatenates any number of fastrings into a complete path.\n  The returned result is a cleaned path by path::clean().\n  Example\n  path::join(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;); // return \u0026#34;x/y/z\u0026#34; path::join(\u0026#34;/x/\u0026#34;, \u0026#34;y\u0026#34;); // return \u0026#34;/x/y\u0026#34; #path::split()\rstd::pair\u0026lt;fastring, fastring\u0026gt; split(const fastring\u0026amp; s);   Divide the path into two parts, dir and file. If the path does not contain a separator, the dir part will be empty.\n  The returned result satisfies the property path = dir + file.\n  Example\n  path::split(\u0026#34;/\u0026#34;); // -\u0026gt; {\u0026#34;/\u0026#34;, \u0026#34;\u0026#34;} path::split(\u0026#34;/a\u0026#34;); // -\u0026gt; {\u0026#34;/\u0026#34;, \u0026#34;a\u0026#34;} path::split(\u0026#34;/a/b\u0026#34;); // -\u0026gt; {\u0026#34;/a/\u0026#34;, \u0026#34;b\u0026#34;} #path::dir()\rfastring dir(const fastring\u0026amp; s);   Return the directory part of the path, the return value is a cleaned path by path::clean().\n  Example\n  path::dir(\u0026#34;a\u0026#34;); // return \u0026#34;.\u0026#34; path::dir(\u0026#34;a/\u0026#34;); // return \u0026#34;a\u0026#34; path::dir(\u0026#34;/\u0026#34;); // return \u0026#34;/\u0026#34; path::dir(\u0026#34;/a\u0026#34;); // return \u0026#34;/\u0026#34;; #path::base()\rfastring base(const fastring\u0026amp; s);   Return the last element of the path.\n  Example\n  path::base(\u0026#34;\u0026#34;); // return \u0026#34;.\u0026#34; path::base(\u0026#34;/\u0026#34;); // return \u0026#34;/\u0026#34; path::base(\u0026#34;/a/\u0026#34;); // return \u0026#34;a\u0026#34; ignores the delimiter at the end path::base(\u0026#34;/a\u0026#34;); // return \u0026#34;a\u0026#34; path::base(\u0026#34;/a/b\u0026#34;); // return \u0026#34;b\u0026#34; #path::ext()\rfastring ext(const fastring\u0026amp; s);   Return the file extension.\n  Example\n  path::ext(\u0026#34;/a.cc\u0026#34;); // return \u0026#34;.cc\u0026#34; path::ext(\u0026#34;/a.cc/\u0026#34;); // return \u0026#34;\u0026#34; "},{"id":25,"href":"/en/co/fs/","title":"File System","section":"Documents for CO","content":"include: co/fs.h.\nco/fs.h implements common file system operations. It is recommended to use '/' uniformly as the path separator on different platforms.\n#Metadata operations\r#fs::exists\rbool exists(const char* path); bool exists(const fastring\u0026amp; path); bool exists(const std::string\u0026amp; path);  Check whether the file exists, the parameter path is path of a file or directory.  #fs::fsize\rint64 fsize(const char* path); int64 fsize(const fastring\u0026amp; path); int64 fsize(const std::string\u0026amp; path);  Get the file size. -1 will be returned if the file does not exist.  #fs::isdir\rbool isdir(const char* path); bool isdir(const fastring\u0026amp; path); bool isdir(const std::string\u0026amp; path);  Check whether the file is a directory, if path exists and is a directory, it returns true, otherwise it returns false.  #fs::mtime\rint64 mtime(const char* path); int64 mtime(const fastring\u0026amp; path); int64 mtime(const std::string\u0026amp; path);  Get the modification time of the file, return -1 when the file does not exist.  #fs::mkdir\rbool mkdir(const char* path, bool p=false); bool mkdir(const fastring\u0026amp; path, bool p=false); bool mkdir(const std::string\u0026amp; path, bool p=false);  Create a directory, the parameter p indicates whether to create the entire path. The parameter p is false by default, and the directory will be created only when the parent directory exists; when the parameter p is true, it is equivalent to mkdir -p, and the parent directory will be created first if it does not exist, .  #fs::remove\rbool remove(const char* path, bool rf=false); bool remove(const fastring\u0026amp; path, bool rf=false); bool remove(const std::string\u0026amp; path, bool rf=false);  Delete a file or directory. When path is a directory, the parameter rf indicates whether to force deletion, the default is false, and only delete an empty directory. If rf is true, it is equivalent to rm -rf, non-empty directory will also be deleted. When path is a file, the parameter rf will be ignored.  #fs::rename\rbool rename(const char* from, const char* to); bool rename(const fastring\u0026amp; from, const fastring\u0026amp; to); bool rename(const std::string\u0026amp; from, const std::string\u0026amp; to);  Rename the file or directory, the parameter from is the original path, and the parameter to is the new path. When the parameter to is a directory, windows requires to and from to be under the same drive. It is generally recommended to use this method when the path specified by the parameter to does not exist. For details, please refer to win32/MoveFile, linux/rename.  #fs::symlink\rbool symlink(const char* dst, const char* lnk); bool symlink(const fastring\u0026amp; dst, const fastring\u0026amp; lnk); bool symlink(const std::string\u0026amp; dst, const std::string\u0026amp; lnk);  Create a soft link, the parameter dst is the path of the target file or directory, and the parameter lnk is the path of the soft link. This function first calls fs::remove(lnk) to delete the old soft link, and then create a new soft link. On windows, this function requires admin permission.  #Code example\rbool x = fs::exists(path); // Determine whether the file exists bool x = fs::isdir(path); // Determine whether the file is a directory int64 x = fs::mtime(path); // Get the modification time of the file int64 x = fs::fsize(path); // Get the size of the file  fs::mkdir(\u0026#34;a/b\u0026#34;); // mkdir a/b fs::mkdir(\u0026#34;a/b\u0026#34;, true); // mkdir -p a/b  fs::remove(\u0026#34;x/x.txt\u0026#34;); // rm x/x.txt fs::remove(\u0026#34;a/b\u0026#34;); // rmdir a/b fs::remove(\u0026#34;a/b\u0026#34;, true); // rm -rf a/b  fs::rename(\u0026#34;a/b\u0026#34;, \u0026#34;a/c\u0026#34;); // mv a/b a/c fs::symlink(\u0026#34;/usr\u0026#34;, \u0026#34;x\u0026#34;); // ln -s /usr x #Read and write files (fs::file)\rThe fs::file class implements the basic read and write operations of files. Unlike fread and fwrite, it has no cache, but reads and writes files directly.\n#file::file\rfile(); file(file\u0026amp;\u0026amp; f); file(const char* path, char mode); file(const fastring\u0026amp; path, char mode); file(const std::string\u0026amp; path, char mode);  The first version is the default constructor, which creates an empty file object without opening a file. The second version is the move constructor. Version 3-5, open the specified file, the parameter path is the file path, and the parameter mode is the open mode. mode is one of 'r', 'w', 'a', 'm', r for read, w for write, a for append, m for modify. When mode is 'r', the file must exist, otherwise the file is not opened. When mode is 'w', the file is automatically created if it does not exist, and the file data is cleared if it already exists. When mode is 'a', the file will be created automatically when it does not exist, and the file data will not be cleared if it already exists. When mode is 'm', the file will be created automatically if it does not exist, and the file data will not be cleared if the file already exists.  #file::~file\r~file();  Destructor, close the previously opened file and release related resources.  #file::close\rvoid close();  Close the file, this method will be automatically called in the destructor. It is safe to call this method multiple times.  #file::exists\rbool exists() const;  Determine whether the file exists. The file may be deleted by other processes. This method can be used to determine whether the previously opened file still exists.  #file::open\rbool open(const char* path, char mode); bool open(const fastring\u0026amp; path, char mode); bool open(const std::string\u0026amp; path, char mode);  This method opens the specified file, mode is the open mode, see the description in Constructor. This method will close the previously opened file before opening a new file.  #file::operator bool\rexplicit operator bool() const;  Convert fs::file to bool type, return true when the file is successfully opened, otherwise return false.  #file::operator!\rbool operator!() const;  It returns true when the file is not opened, otherwise it returns false.  #file::path\rconst fastring\u0026amp; path() const;  This method returns a reference to the file path. If the file object is not associated with any file, the return value will refer to an empty string.  #file::read\rsize_t read(void* buf, size_t n); fastring read(size_t n);  The first version reads data into the specified buffer, n is the number of bytes to be read, and returns the number of bytes actually read. The second version is similar to the first version, but returns a fastring, where n is the number of bytes to be read. The actual bytes read may be less than n, when it reaches the end of the file or an error occurs.  #file::seek\rvoid seek(int64 off, int whence=seek_beg);  Set the current position of the file pointer, the parameter off is the offset position, and the parameter whence is the starting position, which can be one of file::seek_beg, file::seek_cur, file::seek_end. This method is not valid for files opened with mode 'a'.  #file::size\rint64 size() const;  This method returns the size of the file. When the file is not opened, calling this method will return -1.  #file::write\rsize_t write(const void* s, size_t n); size_t write(const char* s); size_t write(const fastring\u0026amp; s); size_t write(const std::string\u0026amp; s); size_t write(char c);  The first version writes a n-byte data. The 2-4th version writes a string. The fifth version writes a single character. This method returns the number of bytes actually written. When the disk space is insufficient or other error occurs, the return value may be less than n. This method has already handled EINTR error internally.  #Code example\rfs::file f; // empty file fs::file f(\u0026#34;xx\u0026#34;,\u0026#39;w\u0026#39;); // write mode f.open(\u0026#34;xx\u0026#34;,\u0026#39;m\u0026#39;); // reopen with modify mode  f.open(\u0026#34;xx\u0026#34;,\u0026#39;r\u0026#39;); // read mode if (f) f.read(buf, 512); // read at most 512 bytes fastring s = f.read(32); // read at most 32 bytes and return fastring  f.open(\u0026#34;xx\u0026#34;,\u0026#39;a\u0026#39;); // append mode if(f) f.write(buf, 32); // write 32 bytes f.write(\u0026#34;hello\u0026#34;); // write a C string f.write(\u0026#39;c\u0026#39;); // write a single character f.close(); // close the file #File Stream (fs::fstream)\rfs::file does not support caching, and the performance of writing small files is poor. For this reason, co/fs.h also implements the fs::fstream class that supports caching, it is designed for writing files and does not support read operations.\n#fstream::fstream\rfstream(); fstream(fstream\u0026amp;\u0026amp; fs); explicit fstream(size_t cap); fstream(const char* path, char mode, size_t cap=8192); fstream(const fastring\u0026amp; path, char mode, size_t cap=8192); fstream(const std::string\u0026amp; path, char mode, size_t cap=8192);  The first version is the default constructor, and the internal cache size is 8k. The second version is the move constructor. The third version uses the parameter cap to specify the size of the cache. Version 4-6 open the specified file, cap is the cache size, and the default is 8k. The parameter mode is one of 'w' or 'a', and the read mode is not supported. When mode is 'w', the file is automatically created when it does not exist, and the file data is cleared if it already exists. When the mode is 'a', the file will be created automatically if it does not exist, and the file data will not be cleared if it already exists.  #fstream::~fstream\r~fstream();  Destructor, close the file, release related resources.  #fstream::append\rfstream\u0026amp; append(const void* s, size_t n);  Append data to the file, the parameter n is the length of the data.  #fstream::close\rvoid close();  Close the file, this method will be automatically called in the destructor. It is safe to call this method multiple times.  #fstream::flush\rvoid flush();  Write the data in the cache to the file.  #fstream::open\rbool open(const char* path, char mode); bool open(const fastring\u0026amp; path, char mode); bool open(const std::string\u0026amp; path, char mode);  Open the specified file. This method will close the previously opened file before opening a new file.  #fstream::operator bool\rexplicit operator bool() const;  Convert fs::fstream to bool type, return true when the file is successfully opened, otherwise return false.  #fstream::operator!\rbool operator!() const;  It returns true when the file is not opened, otherwise it returns false.  #fstream::operator\u0026laquo;\rfstream\u0026amp; operator\u0026lt;\u0026lt;(const char* s); fstream\u0026amp; operator\u0026lt;\u0026lt;(const fastring\u0026amp; s); fstream\u0026amp; operator\u0026lt;\u0026lt;(const std::string\u0026amp; s); fstream\u0026amp; operator\u0026lt;\u0026lt;(const fastream\u0026amp; s); template\u0026lt;typename T\u0026gt; fstream\u0026amp; operator\u0026lt;\u0026lt;(T v);  In versions 1-3, the parameter s is a string type. In the 4th version, the parameter s is a fastream. In the fifth version, T can be any built-in type, such as bool, char, int, double, etc.  #fstream::reserve\rvoid reserve(size_t n);  Adjust the cache capacity, the parameter n is the capacity. If n is less than the previous capacity, the capacity remains unchanged.  #Code example\rfs::fstream s; // cache size: 8k fs::fstream s(4096); // cache size: 4k fs::fstream s(\u0026#34;path\u0026#34;,\u0026#39;a\u0026#39;); // append mode, cache size: 8k fs::fstream s(\u0026#34;path\u0026#34;,\u0026#39;w\u0026#39;, 4096); // write mode, cache size: 4k s.reserve(8192); // make cache size at least 8k  s.open(\u0026#34;path\u0026#34;,\u0026#39;a\u0026#39;); // open with append mode if (s) s \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; 23; // operator\u0026lt;\u0026lt; s.append(\u0026#34;hello\u0026#34;, 5); // append s.flush(); // flush data in cache to file s.close(); // close the file "},{"id":26,"href":"/en/co/os/","title":"Operating System","section":"Documents for CO","content":"include: co/os.h.\n#os\r#os::cpunum\rint cpunum();  Returns the number of system CPU cores.  #os::cwd\rfastring cwd();  Returns path of the current working directory. On windows, \\ in the results will be converted to /.  #os::daemon\rvoid daemon();  Put the current process to run in the background, for linux only.  #os::env\rfastring env(const char* name); bool env(const char* name, const char* value);  The first version, get value of the system environment variable. The second version, added since v2.0.2, set value of the system environment variable, return true on success, otherwise false.  #os::exename\rfastring exename();  Returns name of the current process without path.  #os::exepath\rfastring exepath();  Returns the full path of the current process. On windows, \\ in the results will be converted to /.  #os::homedir\rfastring homedir();  Returns path of the home directory of the current user. On windows, \\ in the results will be converted to /.  #os::pid\rint pid();  Returns the id of the current process.  #os::signal\rtypedef void (*sig_handler_t)(int); sig_handler_t signal(int sig, sig_handler_t handler, int flag=0);   Set a handler for a signal, the parameter sig is the signal value, and the parameter flag is the combination of SA_RESTART, SA_ONSTACK or other options.\n  The parameter flag is only applicable to linux/mac platforms.\n  This function returns the old signal handler.\n  Example\n  void f(int); os::signal(SIGINT, f); // user defined handler os::signal(SIGABRT, SIG_DFL); // default handler os::signal(SIGPIPE, SIG_IGN); // ignore SIGPIPE "},{"id":27,"href":"/en/co/build/","title":"Compiling","section":"Documents for CO","content":"#Compiler requirements\rThe compilers required are as follows:\n Linux: gcc 4.8+ Mac: clang 3.3+ Windows: vs2015+  #xmake\rCO recommends using xmake as the build tool.\n#Install xmake\rFor Windows, mac and debian/ubuntu, you can go directly to the release page of xmake to get the installation package. For other systems, please refer to xmake\u0026rsquo;s Installation instructions.\nXmake disables compiling as root by default on Linux. ruki says it is not safe. You can add the following line to ~/.bashrc to enable it:\nexport XMAKE_ROOT=y #Build\rRun commands below in the root directory of CO to build libco and other projects:\nxmake -a # build all projects (libco, gen, test, unitest) To enable HTTP and SSL features, build with the following commands:\nxmake f --with_libcurl=true --with_openssl=true xmake -a Xmake may install libcurl and openssl from the network, which may be slow.\n-a in the command line means to build all projects in CO. If -a is not added, only libco will be built by default. In addition, users may use -v or -vD to print more detailed compiling information:\nxmake -v -a #Compiling options\rXmake provides the xmake f command to configure compiling options. Note that multiple options must be set in a single xmake f command.\n#Build debug version of libco\rxmake f -m debug xmake -v #Build dynamic library\rxmake f -k shared xmake -v Note that dynamic library is not supported on Windows.\n#Build 32-bit libco\r Windows  xmake f -a x86 xmake -v  Linux  xmake f -a i386 xmake -v The -a in xmake f command means arch. The arch supported by different platforms may be different. Run xmake f --help to see the details.\n#set vs_runtime on Windows\rOn Windows, CO uses the MT runtime library by default, and users can use xmake f to configure it:\nxmake f --vs_runtime=MD xmake -v #Android and IOS support\rCO can also be built on Android and IOS platforms, see Github Actions for details. Since the author has no front-end development experience, it has not been tested on Android and IOS.\n android  xmake f -p android --ndk=/path/to/android-ndk-r21 xmake -v  ios  xmake f -p iphoneos xmake -v #Build and run unitest code\rco/unitest contains some unit test code, run the following commands to build and run the test program:\nxmake -b unitest # build unitest xmake r unitest -a # run all unit tests xmake r unitest -os # run unit test: os xmake r unitest -json # run unit test: json #Build and run test code\rco/test contains some test code, add xx.cc source file in the co/test directory or its subdirectories, and then run xmake -b xx in the root directory of CO to build it.\nxmake -b flag # compile test/flag.cc xmake -b log # compile test/log.cc xmake -b json # compile test/json.cc xmake -b rpc # compile test/rpc.cc  xmake r flag -xz # test flag library xmake r log # test log library xmake r log -cout # also log to terminal xmake r log -perf # test performance of log library xmake r json # test json xmake r rpc # start rpc server xmake r rpc -c # start rpc client #Build and use gen\rxmake -b gen cp gen /usr/local/bin/ gen hello_world.proto The proto file format can refer to hello_world.proto.\n#Install libco\rAfter building libco, you can use the xmake install command to install libco to the specified directory:\nxmake install -o pkg # install to pkg xmake i -o pkg # same as above xmake i -o /usr/local # install to /usr/local #Install libco from xmake repo\rxrepo install -f \u0026#34;openssl=true,libcurl=true\u0026#34; co #cmake\rizhengfan helped to provide the cmakefile:\n Only build libco by default. The library files are in build/lib directory, and the executable files are in build/bin directory. You can use BUILD_ALL to build all projects. You can use CMAKE_INSTALL_PREFIX to specify the installation directory.  #Build libco by default\rmkdir build \u0026amp;\u0026amp; cd build cmake .. make -j8 #Build all projects\rmkdir build \u0026amp;\u0026amp; cd build cmake .. -DBUILD_ALL=ON -DCMAKE_INSTALL_PREFIX=/usr/local make -j8 make install #Enable HTTP and SSL features\rTo use HTTP or SSL features, libcurl, zlib, and openssl 1.1.0 or above must be installed.\nmkdir build \u0026amp;\u0026amp; cd build cmake .. -DBUILD_ALL=ON -DWITH_LIBCURL=ON -DWITH_OPENSSL=ON make -j8 #Install libco from vcpkg\rvcpkg install co:x64-windows  # HTTP \u0026amp; SSL support vcpkg install co[libcurl,openssl]:x64-windows "}]